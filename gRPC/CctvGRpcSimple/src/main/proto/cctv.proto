
/////////////////////////////////////////////////////////////////////////////////////
//  Links:
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/json-transcoding?view=aspnetcore-8.0
//      https://www.infoq.com/articles/dotnet-grpc-json-transcoding/
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/json-transcoding-binding
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/json-transcoding-openapi?view=aspnetcore-8.0
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-8.0
//      https://cloud.google.com/endpoints/docs/grpc/transcoding
//      https://cloud.google.com/apis/design/naming_convention
//
/////////////////////////////////////////////////////////////////////////////////////

syntax = "proto3";

option csharp_namespace = "Com.Efacec.ES.TRP.Efarail.Cctv.Grpc.Enums.v1";
option java_package = "com.efacec.es.trp.efarail.cctv.grpc.v1";

//package com.efacec.es.trp.efarail.cctv.grpc.v1;

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CCTV enums
//
// NOTE: since we're dealing w/ OPEN enums, the first element must be zero (0);
//

// MsgVersionMod
// Normally used when version are requested
enum VersionMod {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
	VERMOD_ALL = 0;
	VERMOD_GRPC = 1;
	VERMOD_SA = 2;
	VERMOD_AGENT = 3;
	VERMOD_PROXY = 4;
}

// SourceObj
// Normally used when target equips connections information is requested.
enum SourceObj {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
	SRCOBJ_INVALID = 0;
	SRCOBJ_EQUIP = 1;
	SRCOBJ_SEQUENCE = 2;
	SRCOBJ_REPLAY = 3;
	SRCOBJ_RECORDING = 4;
}

// SequenceOper
// Sequence operations used, only after a sequence as been started, to execute an operation.
enum SequenceOper {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
	SEQOPE_STOP = 0;
	SEQOPE_PAUSE = 1;
	SEQOPE_RESTART = 2;
	SEQOPE_STEP_PREVIOUS = 3;
	SEQOPE_STEP_NEXT = 4;
}

// SequenceState
// Sequences state type signalling the running sequence actual state.
enum SequenceState {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
	SEQSTA_NOT_STARTED = 0;
	SEQSTA_STOP = 1;
	SEQSTA_PLAY = 2;
	SEQSTA_PAUSE = 3;
}

// SequenceMode
// Sequences mode, i.e., ciclic or no ciclic.
enum SequenceMode {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
	SEQMOD_UNDEF = 0;
	SEQMOD_CICLIC = 1;
	SEQMOD_NO_CICLIC = 2;
}

// MacroOper
// Macro operation
enum MacroOper {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
    MACOPE_START = 0;
    MACOPE_STOP = 1;
}

// ReplyValue
// All possible reply values
enum ResponseValue {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
	R_OK = 0;
    R_ERROR = 1;
    R_NOTIMPLEMENTED = 2;
    R_NOTSUPPORTED = 3;
    R_INVALIDPARAMETER = 4;
    R_INVALIDEQUIPMENT = 5;
    R_CONFFILE_FAILOPEN = 6;
    R_IPC_CREATION = 7;
    R_IPC_COMMFAIL = 8;
    R_CORBA_EXCEPTION = 9;
    R_DB_ERROR = 10;
    R_DB_NODATABASE = 11;
    R_DB_CONNECTIONTIMEDOUT = 12;
    R_DB_NODATAFOUND = 13;
    R_EQUIP_INITIALIZING = 14;
    R_EQUIP_TERMINATING = 15;
    R_EQUIP_RESETING = 16;
    R_EQUIP_NOTINIT = 17;
    R_EQUIP_ALREADYINIT = 18;
    R_EQUIP_INVALIDSTATE = 19;
    R_EQUIP_NOSTATION = 20;
    R_EQUIP_LOCKED = 21;
    R_EQUIP_PROTOUNKNOWN = 22;
    R_EQUIP_PROTONOPROTOCOL = 23;
    R_EQUIP_PROTOTRYTIMEOUT = 24;
    R_EQUIP_PROTOSENDFAIL = 25;
    R_EQUIP_PROTOFAIL = 26;
    R_EQUIP_PROTOACK = 27;
    R_EQUIP_PROTOACKLASTMSG = 28;
    R_EQUIP_EQDATAUNKNOWN = 29;
    R_EQUIP_EQDATAINCOMPLETE = 30;
    R_EQUIP_EQDATANOTOK = 31;
    R_EQUIP_EQDATAOK = 32;
    R_EQUIP_ANSWERINVALID = 33;
    R_EQUIP_ANSWERINCOMPLETE = 34;
    R_EQUIP_ANSWERNOTOK = 35;
    R_EQUIP_ANSWEROK = 36;
    R_EQUIP_ANSWERCOMMERROR = 37;
    R_EQUIP_CAM_INVALIDPRESET = 38;
    R_EQUIP_MPX_INVALIDCHANNEL = 39;
    R_EQUIP_MPX_INVALIDPAGE = 40;
    R_EQUIP_MATRIX_INVALIDCHANNELIN = 41;
    R_EQUIP_MATRIX_INVALIDCHANNELOUT = 42;
    R_VC_SERVERERROR = 43;
    R_VC_PATHBROKEN = 44;
    R_VC_PATHEMPTY = 45;
    R_VC_PATHBOUNDERROR = 46;
    R_VC_REFERENCEERROR = 47;
    R_VC_OUTOFMEMORY = 48;
    R_VC_STATUSERROR = 49;
    R_VC_PATHNOTFOUND = 50;
    R_VC_SOURCEERROR = 51;
    R_VC_TARGETERROR = 52;
    R_VC_UNKNOWNERROR = 53;
    R_SEQ_ERROR = 54;
    R_SEQ_INVALIDSEQID = 55;
    R_SEQ_NOTAVALIDSEQUENCE = 56;
    R_SEQ_INVALIDTARGET = 57;
    R_SEQ_COULDNOTSTART = 58;
    R_SEQ_ALREADYPLAYING = 59;
    R_SEQ_ALREADYPAUSED = 60;
    R_SEQ_NOTPLAYING = 61;
    R_SEQ_UNDEFSTATE = 62;
    R_MACRO_ERROR = 63;
    R_MACRO_COULDNOTSTART = 64;
    R_MACRO_NOTRUNNING = 65;
    R_SCHED_INITERR = 66;
    R_SCHED_SPAWNERR = 67;
    R_EQUIPLOCK_INSUFICIENTPRIVILEGES = 68;
    R_EQUIPLOCK_ALREADYLOCKED = 69;
    R_STATIONUNAVAILABLE = 70;
}

// AlarmType
// All alarm types
enum AlarmType {
    ALRTYP_UNDEFINED = 0;
    ALRTYP_DBCOMMFAIL = 1;
    ALRTYP_SACOMMFAIL = 2;
    ALRTYP_SASTATECHANGE = 3;
    ALRTYP_SAINITIALIZE = 4;
    ALRTYP_SATERMINATE = 5;
    ALRTYP_SESSIONBEGIN = 6;
    ALRTYP_SESSIONEND = 7;
    ALRTYP_OBJREFERROR = 8;
    ALRTYP_VIDEOCONNECTERROR = 9;
    ALRTYP_VIDEOSOURCEINVALID = 10;
    ALRTYP_VIDEOTARGETINVALID = 11;
    ALRTYP_VIDSEQSTATECHANGE = 12;
    ALRTYP_MAXSEQUENCES = 13;
    ALRTYP_MACROSTATECHANGE = 14;
    ALRTYP_SCHEDULEDACTIONEXECUTED = 15;
    ALRTYP_GUICOMMFAIL = 16;
    ALRTYP_STATIONCOMMFAIL = 17;
    ALRTYP_STATIONSTATECHANGE = 18;
    ALRTYP_EQUIPCOMMFAIL = 19;
    ALRTYP_EQUIPSTATECHANGED = 20;
    ALRTYP_EQUIPSPECIFICSTATECHANGED = 21;
    ALRTYP_EQUIPVIDEOINFAIL = 22;
    ALRTYP_EQUIPVIDEOOUTFAIL = 23;
    ALRTYP_IOACTIVE = 24;
    ALRTYP_CLOCKSYNCARRIVED = 25;
    ALRTYP_EQUIPVIDEOINTAMPER = 26;
    ALRTYP_EQUIPMOTIONDETECTED = 27;
    ALRTYP_VRNOSPACELEFT = 28;
    ALRTYP_VRRECORDFAILURE = 29;
    ALRTYP_VIDSEQADDED = 30;
    ALRTYP_VIDSEQREMOVED = 31;
    ALRTYP_VIDSEQCHANGE = 32;
    ALRTYP_MACROADDED = 33;
    ALRTYP_MACROREMOVED = 34;
    ALRTYP_MACROCHANGE = 35;
    ALRTYP_AGENTCOMMFAIL = 36;
    ALRTYP_EQUIPLOCKFAIL = 37;
    ALRTYP_RECQUALITYCHANGE = 38;
    ALRTYP_MONITORGROUPCHANGED = 39;
    ALRTYP_AUTOVIDEOCONNECTERROR = 40;
    ALRTYP_USERALARM = 41;
    ALRTYP_REPLAYSTOPED = 42;
    ALRTYP_HQRECQUOTAEXCEEDED = 43;
}

//
// Lock/Unlock equipments 
enum LockUnlockType {
	// since we're dealing w/ OPEN enums, the first element must be zero (0);
    LCK_LOCK = 0;
    LCK_UNLOCK = 1;
}

//
// The equipments generic state.
enum EquipGenericState {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    EGS_UNDEF = 0;
    EGS_OK = 1;
    EGS_ERROR = 2;
    EGS_LOCKED = 3;
}

//
// The equipments specific state.
enum EquipSpecificState {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    ESS_UNDEFINED = 0;
    ESS_CAM_IDLE = 1;
    ESS_CAM_AUTOPAN = 2;
    ESS_CAM_RESETING = 3;
    ESS_VR_NOMEDIA = 4;
    ESS_VR_PLAYBACK = 5;
    ESS_VR_RECORD = 6;
    ESS_VR_STOP = 7;
    ESS_VR_PAUSE = 8;
    ESS_VR_FASTFORWARD = 9;
    ESS_VR_REWIND = 10;
    ESS_VR_REVERSEPLAY = 11;
    ESS_VR_TIMEDATESEARCH = 12;
    ESS_MPX_MULTIPLEX = 13;
    ESS_MPX_FULLSCREEN = 14;
    ESS_MPX_CYCLE = 15;
    ESS_MPX_FREEZE = 16;
    ESS_MPX_VCR = 17;
    ESS_CODEC_DISCONNECTED = 18;
    ESS_CODEC_CONNECTED = 19;
    ESS_CODEC_CONNECTING = 20;
    ESS_CODEC_DISCONNECTING = 21;
    ESS_SENSOR_IDLE = 22;
    ESS_SENSOR_ACTIVE = 23;
    ESS_ACTUATOR_IDLE = 24;
    ESS_ACTUATOR_ACTUATED = 25;
    ESS_ACTUATOR_ACTIVE = 26;
    ESS_WATCHDOG_ENABLED = 27;
    ESS_WATCHDOG_DISABLED = 28;
}

//
// The cameras presets oprations.
enum CameraPtzfPresetOperation {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    CPO_ACTIVATE = 0;
    CPO_ADD = 1;
    CPO_UPDATE = 2;
    CPO_DELETE = 3;
}

//
// The actuator operations
enum ActuatorOperation {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    ACO_ACTUATE = 0;
    ACO_DEACTUATE = 1;
}

//
// The user acces type
enum UserAccessType {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    UAT_LOGIN = 0;
    UAT_LOGOUT = 1;
}




























































////////////////////////////////////////////////////////////////////////////////////
//
// CCTV messages
//
//

//
// THE empty message
message Empty {} 

//
// Generic numeric reply
message Response {
	// The numeric value to return to the caller.
	ResponseValue value = 1;
	// A description of the returned value, if needed/wanted (can be left empty).
	string desc = 2;
}

//
// Generic numeric message
message NumericResponse {
	// The numeric value.
	Response response = 1;
	// The numeric response identification
	int64 id = 2;
}

//
// Generic multiple numeric message
message NumericsResponse {
	// The numeric value.
	Response response = 1;
	// The 
	repeated int64 ids = 2;
}

//
// The user message
message User {
    // The user identification
    google.protobuf.Int64Value id = 1;
    // The user name
    google.protobuf.StringValue login = 2;
    // The user name
    google.protobuf.StringValue name = 3;
}

//
// The user access request: login or logout.
message UserAccessRequest {
    // The user identification
    User user = 1;
    // The acces type: login or logout.
    UserAccessType userAccessType = 2;
}

//
// Generic version reply
message CctvVersion {
	// The version value.
	int64 version = 1;
	// The subversion value.
	int64 subVersion = 2;
	// The revision value.
	int64 revision = 3;
	// The build value.
	int64 build = 4;
	// A description of the returned value, if needed/wanted (can be left empty).
	string desc = 5;
    // The module.
    VersionMod module = 6;
}

//
// Generic multiple versions reply
message ListCctvVersions {
    // The requested modules versions.
    repeated CctvVersion versions = 1;
}

//
// The current WorkStation information. Normally used by the auditing system.
message WorkstationInformation {
	// The user name of the logged user, i.e., the user login.
	google.protobuf.StringValue userName = 1;
	// The workstation identification.
	google.protobuf.Int64Value id = 2;
    //
    // TODO: should we add the user id?
}

//
// Message used when version are requested.
message VersionsRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
    // The requested module.
    VersionMod module = 2;
}

// Basic message holder for connections, i.e., only the source and target data. 
message ConnectionInfo {
	// The source, normally a camera, identification  but could also be a sequence id...
	google.protobuf.Int64Value sourceId = 1;
	// The target equipment, normally a monitor, identification.
	google.protobuf.Int64Value targetId = 2;
}

// Set source in target connection attempts data.
message ConnectionRequest {
	// The basic, i.e. source & target, data.
	ConnectionInfo connectionInfo = 1;
	// The source equipment port (can be left without a value, i.e. 0).
	google.protobuf.Int64Value sourcePort = 2;
	// The target equipment port (can be left without a value, i.e. 0).
	google.protobuf.Int64Value targetPort = 3;
	// Used, if needed to set the address where to connect.
	google.protobuf.StringValue address = 4;
}

//
// Struct used while setting connections between sources equipments, normally cameras
// and targets, normally monitors.
message ConnectionsRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
	// List of connections to attempt.
	repeated ConnectionRequest connectionRequest = 2;
}

//
// Message used when a list of IDs is needed.
message ListIds {
	// The workstation information, if needed.
	WorkstationInformation workStationInfo = 1;
	// Items Ids, whatever tey mean, i.e., sources equipments, targets equipments, 
    // sequences ids, active sequences handles, etc.
	repeated google.protobuf.Int64Value ids = 2;
}

//
// Message used while obtaining targets, normally monitors, connection info. 
// This is not directly used by the Operation service.
message DetailedConnectionInfo {
	// The target identification.
	int64 targetId = 1;
	// The type of active source in a target.
	SourceObj sourceObj = 2;
	// Additional info for SourceObj.REPLAY type.
	int64 handle = 3;
	// The source identification i.e,, an equipment id, a sequence id, etc.
	int64 sourceId = 4;
	// The source station identification when available/used/set.
	int64 stationId = 5;
	// The recorder source identification when available/used/set.
	int64 recorderSourceId = 6;
}

//
// Message used while obtaining targets, normally monitors, connection info.
message DetailedConnectionsInfoResponse {
	// The request reply.
	Response response = 1;
	// the list of targets connection information.
	repeated DetailedConnectionInfo detailedConnInfo = 2;
}

//
// Return message when multiple requests are sent in a single invocation.
message MultipleRequestsResponse {
	// Global reply for the request. If this is OK, then ALL requests were successful. 
	Response globalResponse = 1;
	// The list of IDs and request status of each one of them. 
	// NOTE: if the globalReply is OK, there no need to use this item.
	repeated NumericResponse specificResponses = 2;
}

//
// Information associated to a sequence start.
message SequenceConnInfo {
	// The connection info, i.e., sequence, the source item in the message, and target.
	ConnectionInfo connectionInfo = 1;
	// Used for syncronous sequences. Values from 0..30, in intervals of 5 meaning seconds.
	// NOTE: nowadays, @2406, not used anymore... but here just in case
	google.protobuf.StringValue syncTime = 2;
}

//
// 
message StartSequencesRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
	// The sequences information.
	repeated SequenceConnInfo sequenceConnInfo = 2;
}

//
// The sequence basic information, normally used to define a sequence but NOT a running one.
message Sequence {
	// The sequence identification.
	int64 id = 1;
	// The sequence name.
	string name = 2;
	// The sequence mode: undefined, ciclic or non ciclic.
	SequenceMode mode = 3;
}

//
// Reply message when all sequences are requested.
message ListSequences {
	// All the sequences
	repeated Sequence sequences = 1;
}

//
// The running sequence data holder 
message RunningSequence {
	// The sequence identification. 
    // May not be needed if the handle is set. It can be useful, but not always mandatory.
	google.protobuf.Int64Value id = 1;
	// The running sequence handle, i.e., the running sequence identification.
	google.protobuf.Int64Value handle = 2;
	// The running sequence active target, normally not needed but can be sent just in case.
	google.protobuf.Int64Value targetId = 3;
	// The sequence state. Depending on the operation, this value could be not set.
	SequenceState state = 4;
	// Used for syncronous sequences. Values from 0..30, in intervals of 5 meaning seconds.
	// NOTE: nowadays, @2406, not used anymore... but here just in case.
	google.protobuf.Int64Value syncTime = 5;
}

//
// The running sequences data holder 
message RunningSequencesRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
	// The running sequencse handles, i.e., the running sequence identification
	repeated RunningSequence runningSequences = 2;	
}

//
// The running sequence reply message.
message RunningSequenceResponse {
	// The running sequence handle and target
	RunningSequence runningSequence = 1;
	// The running sequence state, i.e., one from SequenceOper (When )
	SequenceOper SequenceOper = 2;
}

//
// The running sequences reply message, normally used when obtaining all running sequences.
message RunningSequencesResponse {
	// The running sequences reply message
	repeated RunningSequenceResponse runningSequencesResponse = 1;
}

//
// Used when stopping, pausing, restarting sequences. 
// Only a single SequenceOper can be applied to the given list of sequences or targets.
message SequencesOperationRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
	// The sequence oper: stop, pause, restart, next or previous step.
	SequenceOper sequenceOper = 2;
	// Items Ids, whatever they mean, i.e., targets equipments or sequences handles 
    // depending on the set prop from MsgRunningSequence.
	repeated RunningSequence runningSequences = 3;
}

//
// Used to start and stop macros. 
// Only a single MacroOper can be applied to the given list of macros.
message MacrosOperationRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
	// The macro oper, i.e., start or stop.
	MacroOper macroOper = 2;
	// Macros Ids.
	repeated google.protobuf.Int64Value ids = 3;
}

//
// Alarm information
message Alarm {
    // The alarm identification
    AlarmType type = 1;
    // The alarm parameters
    string params = 2;
    // The alarm equipment identification, if any.
    int64 equipmentId = 3;
    // The alarm station identification, if any.
    int64 stationId = 4;
    // The alarm trigger, if any.
    int64 trigger = 5;
}

//
// List of alarms, normally used when obtaing the list of ALL active alarms.
message ListAlarms {
    // The list of alarms.
    repeated Alarm alarms = 1;
}

//
// Message used when a lock, or unlock, equipments request is invoked.
message LockUnlockEquipsRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
	// The list of identifications, normally from cameras.
	ListIds ids = 2;
    // The lock or unlock Operation.
    LockUnlockType LockUnlock = 3;
}

//
// Equipment generic state
message EquipmentGenericState {
    // The equipment identification
    int64 equipId = 1;
    // The generic state.
    EquipGenericState state = 2;
}

//
// The equipments generic state response
message EquipmentsGenericStateResponse {
    repeated EquipmentGenericState equipsGenericStates = 1;
}

//
// Equipment specific state
message EquipmentSpecificState {
    // The equipment identification
    int64 equipId = 1;
    // The generic state.
    EquipSpecificState state = 2;
}

//
// The equipments specific state response
message EquipmentsSpecificStateResponse {
    repeated EquipmentSpecificState equipsSpecificStates = 1;
}

//
// An equipment associated data.
message Equipment {
    // The equipment identification.
    google.protobuf.Int64Value id = 1;
    // The equipment name.
    google.protobuf.StringValue name = 2;
    // The equipment type.
    google.protobuf.Int64Value type = 3;
    // Is the equipment enabled?
    google.protobuf.BoolValue enabled = 4;
    // The equipment station identification.
    google.protobuf.Int64Value stationId = 5;
    // The equipment communications settings.
    google.protobuf.StringValue commSettings = 6;
    // The equipment generic state.
    EquipGenericState genericState = 7;
    // The equipment specific state.
    EquipSpecificState specificState = 8;
    // The equipment generic configuration.
    google.protobuf.StringValue genericConfig = 9;
    // The equipment specific configuration.
    google.protobuf.StringValue specificConfig = 10;
    // The equipment associated box identification, if any.
    google.protobuf.Int64Value boxId = 11;
}

//
// The equipments response
message ListEquipments {
    repeated Equipment equipments = 1;
}

//
// An equipment associated data.
message EquipmentConfiguration {
    // The equipment identification.
    google.protobuf.Int64Value id = 1;
    // The equipment communications settings.
    google.protobuf.StringValue commSettings = 2;
    // The equipment generic configuration.
    google.protobuf.StringValue genericConfig = 3;
    // The equipment specific configuration.
    google.protobuf.StringValue specificConfig = 4;
}

//
// The equipments configuration response
message EquipmentsConfigurationResponse {
    repeated EquipmentConfiguration equips = 1;
}

//
// A camera preset CRUD operation message.
message CameraPtzfSavePreset {
    // The camera identification.
    google.protobuf.Int64Value camId = 1;
    // The ptzf camera preset slot index.
    google.protobuf.Int64Value presetIdx = 2;
    // The ptzf camera preset name.
    google.protobuf.StringValue presetName = 3;
}

//
// The cameras preset CRUD operations request.
message CameraPtzfSavePresetsRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
    // The camera identification.
    repeated CameraPtzfSavePreset camerasPtzfSavePresets = 2;
    // The request operation: add, update and delete
    CameraPtzfPresetOperation camPtzfPresetOper = 3;
}

//
// The cameras preset CRUD operation response.
message CameraPtzfSavePresetResponse {
	// The response.
	Response response = 1;
    // The camera preset saving information.
    CameraPtzfSavePreset camPtzfSavePreset = 2;
}

//
// The cameras preset CRUD operations request.
message CameraPtzfSavePresetsResponse {
    // The list of saving cameras presets responses.
    repeated CameraPtzfSavePresetResponse camPtzfSavePresetResponse = 1;
}

//
// The actuator operation: actuate or deactuate.
message ActuatorOperationRequest {
    // The actuator identification.
    google.protobuf.Int64Value actuatorId = 1;
    // The actuator operation.
    ActuatorOperation oper = 2;
}

//
// The actuator operations request.
message ActuatorOperationsRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
    // The list of actuator operations.
    repeated ActuatorOperationRequest actuatorsOperRequest = 2;
}

//
// Single actuator operation request response.
message ActuatorOperationResponse {
	// The response.
	Response response = 1;
    // The actuator operation.
    ActuatorOperation actuatorOper = 2;
}

//
// Actuators operations requests response.
message ActuatorOperationsResponse {
	// The response.
	repeated ActuatorOperationResponse actuatorsOpersResponse = 1;
}

//
// The "Not Acknowledged Alarm".
message NotAcknowledgedAlarm {
    // The associated monitors list identification.
	int64 groupId = 1;
    // The monitor identification (of course, the given monitor identification, if valid, must be a monitor "belonging" to the group set. ).
	int64 nMonId = 2;
    // The not acknowledged alarm identification.
	int64 nAlarmId = 3;
    // The not acknowledged alarm position "inside" the alarms stack list.
	int64 nPos = 4;
    // The not acknowledged alarm description.
	string sDescription = 5;
    // The not acknowledged alarm source equipment identification, normally pointing to a camera.
	int64 nSourceId = 6;
    // The not acknowledged alarm source equipment, normally a camera, preset, if set and if the camera is a PTZ one.
	int64 nPrePos = 7;
}

//
// The acknowledge alarms response, which, basicaly, is the new list of NotAcknowledgeAlarms.
message AcknowledgeAlarmsResponse {
    repeated NotAcknowledgedAlarm notAcknowledgedAlarms = 1;
}

//
// The "Set Alarms On Monitor" request. Basically is a list of NotAcknowledgeAlarms identifications and target equipments, normally monitors, identifications.
message SetAlarmsOnMonitorRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
    // The connections info, i.e., source and target identifications pairs.
    repeated ConnectionInfo connectionsInfo = 2;
}

//
// The mark an user alarm message associated with the given source identification. 
message MarkUserAlarmRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
    // The user identification.
    google.protobuf.Int64Value userId = 2;
    // The source equipment identification.
    google.protobuf.Int64Value equipId = 3;
    // The alarm sub type identification. (from STV DB. t_sensoralarmsubtypes)
    google.protobuf.Int64Value alarmSubtypeId = 4;
    // The marking parameters. (from STV DB: t_sensralarsubtypes_tags_parms)
    google.protobuf.StringValue param = 5;
    // The marking subtype tag id of the sensor. (from STV DB: t_sensoralarmsubtypes_tags)
    google.protobuf.StringValue alarmSensorSubtypeTagId = 6;
    // The marking notes. (from STV DB: t_video_recalarm_params)
    google.protobuf.StringValue notes = 7;
}


//
// A sensor alarm type.
message SensorAlarmType {
    // The sensor alarm type identifiction.
    int64 id = 1;
    // The sensor alarm type description.
    string description = 2;
}

//
// A list of sensor alarm types.
message ListSensorAlarmTypes {
    // The list of SensorAlarmType.
    repeated SensorAlarmType sensorAlarmTypes = 1;
}

//
// A sensor alarm subtype.
message SensorAlarmSubtype {
    // The sensor alarm type identifiction.
    int64 id = 1;
    // The sensor alarm type description.
    string description = 2;
    // The sensor alarm type.
    SensorAlarmType sensorAlarmType = 3;
    // Indicates if the sensor alarm subtype can be searchable in any searchable GUI.
    bool isGuiSearchable = 4;
    // The sensor alarm subtype priority.
    int64 priority = 5;
}

//
// A list of sensor alarm subtypes.
message ListSensorAlarmSubtypes {
    // The list of SensorAlarmSubtype.
    repeated SensorAlarmSubtype sensorAlarmSubtypes = 1;
}

//
// A sensor alarm subtype tag.
message SensorAlarmSubtypesTag {
    // The sensor alarm type identifiction.
    int64 id = 1;
    // The sensor alarm subtype tag description.
    string description = 2;
    // The sensor alarm subtype tag name.
    string name = 3;
    // True if the sensor alarm subtype tag needs parameters when used.
    bool hasParameters = 4;
    // True if the sensor alarm subtype tag allows for notes to be added when used.
    bool allowNotes = 5;
    // The sensor alarm subtype tag associated subtype.
    SensorAlarmSubtype sensorAlarmSubtype = 6;
    // Trie if the sensor alarm subtype tag is te default one in the system.
    bool isDefault = 7;
}

//
// A list of sensor alarm subtype tags.
message ListSensorAlarmSubtypesTags {
    // The list of SensorAlarmSubtype.
    repeated SensorAlarmSubtypesTag sensorAlarmSubtypesTags = 1;
}

//
// The message used to edit an already user/manual alarm marking.
//workstationInformation_ logInfo, int alarmId, int userId, String sTag, String sSensorAlarmSubtypeTagId, String notes, boolean isMarkingEnd
message MarkUserAlarmEditRequest {
	// The workstation information.
	WorkstationInformation workStationInfo = 1;
    // The alarm identification.
    google.protobuf.Int64Value alarmId = 2;
    // The user identification.
    google.protobuf.Int64Value userId = 3;
    // The marking tag parameter. 
    google.protobuf.StringValue tag = 4;
    // The marking subtype tag id of the sensor. 
    google.protobuf.StringValue alarmSensorSubtypeTagId = 5;
    // The marking notes. (from STV DB: t_video_recalarm_params)
    google.protobuf.StringValue notes = 6;
    // If true it means the marking just occurred. False for all other usages.
    google.protobuf.BoolValue isMarkingEnd =  7;

}



























































////////////////////////////////////////////////////////////////////////////////////
//
// CCTV configuration interface (TAO IDL: configuration.idl)
//
//
service Configuration {
    
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Equipments interfaces
    //
    
    //
    // Returns 
    // TAO IDL: 
    //          - ??????? int getAllEquipsConf(int stationId, listEquipsConfHolder lEquips); ??????
    // TODO: probably will required MORE developments in StvSa. There's no such API as "getAllEquips(..)"'
    rpc GetAllEquipments(ListIds) returns (ListEquipments);




	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Sequences interfaces 
	//
	
    // Obtain ALL configured sequences in the system.
	// If the given MsgListIds is empty, or null, this method returns ALL sequences otherwise, 
	// it filters the result by the MsgListIds configured workstation and/or sequences identification.
    // TAO IDL: 
    //          - int getAllVidSeqs(...);
	rpc GetAllSequences(ListIds) returns (ListSequences);


}





























































////////////////////////////////////////////////////////////////////////////////////
//
// CCTV operation interface (TAO IDL: operation.idl)
//
//
service Operation {

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Generic operations
	//

    //
    // Signals the CCTV service an user just logged in or out.
    // TAO IDL:
    //          - void userAccess(short type, int userId);
    rpc UserAccess(UserAccessRequest) returns (Response);

	// Obtain the Operation service version
    // TAO IDL:
    //          - void getAgentVersions(...);
	//          - void getStvSaVersion(...);
	rpc GetVersions(VersionsRequest) returns (ListCctvVersions);

	// Obtains the given targets connection information, if any.
    // TAO IDL: 
    //          - int getSourcesInTargets(int[] targets, ...);
	rpc GetDetailedConnectionsInfo(ListIds) returns (DetailedConnectionsInfoResponse);
	
	// Setting connections between sources equipments, normally cameras, and targets, normally monitors.
	// NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
	//       is OK, there's' no need to use the specific target response item.
    // TAO IDL: 
    //          - int setSourceinTarget(...);
	rpc Connect(ConnectionsRequest) returns (MultipleRequestsResponse);

	// Disconnects all the given targets. Returns a list of results for each given target.
	// NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
	//       is OK, there's' no need to use the specific target response item.
    // TAO IDL: 
    //          - int disconnectVideoFromTarget(workstationInformation_ logInfo, int targetId);
    //          - int disconnectVideoFromTargetEx(workstationInformation_ logInfo, int[] targetIds, ...);
    //          or w/ source id set to -1 (i.e., invalid id):
    //          - int setSourceinTarget(workstationInformation_ logInfo, -1, int TargetID, 1, 1);
	rpc Disconnect(ListIds) returns (MultipleRequestsResponse);

    //
    // Obtain ALL active alarms.
    // TAO IDL: 
    //          - void getAlarms(...);
    rpc GetAlarms(WorkstationInformation) returns (ListAlarms);

    //
    // Method used to acknowledge alarms in the alarms monitor list.
    // TAO IDL:
    //          - int acknowledgeAlarms(workstationInformation_ logInfo, long[] ackAlarms, listNotAckAlarmsHolder alarms);
    rpc AcknowledgeAlarms(ListIds) returns (AcknowledgeAlarmsResponse);

    //
    // Returns all NotAcknowledgedAlarms.
    // TAO IDL:
    //          - int getNotAckAlarms(...);
    rpc GetNotAcknowledgedAlarms(WorkstationInformation) returns (AcknowledgeAlarmsResponse);

    //
    // Used to set a NotAcknowledgedAlarm in a monitor. 
    // For each given monitor:
    //      - if it belongs to a group of monitors, the alarm is set in it, moving the active alarm in that 
    //        same monitor, if present, to another position in the stack. This does NOT ACKNOWLEDGE the alarm.
    //      - if it doesn't belong to a group of monitor, i.e., if it's a normal monitor, the alarm is set in 
    //        it and the alarm is ACKNOWLEDGED!
    // 
    // TAO IDL:
    //          For a group monitor:
    //          - int setAlarmOnMonitor(workstationInformation_ logInfo, long alarmId, int monitorId);
    //          or if the given monitor is groupless monitor:
    //          - int ackAlarmToTarget(workstationInformation_ logInfo, long alarmId, int monitorId); - THIS ACKNOWLEDGE THE ALARM(s).
    rpc SetAlarmsOnMonitor(SetAlarmsOnMonitorRequest) returns (MultipleRequestsResponse);

    //
    // Used to reset a monitors group.
    // TAO IDL:
    //          - int resetMonitorGroup(int groupId);
    rpc ResetMonitorGroups(ListIds) returns (MultipleRequestsResponse);









	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// User alarm marking operations
	//

    //
    // Used to mark an user/manual alarm associated with the given source identification. 
    // This method return information is the marking handle which can be used to change the user marking.
    // TAO IDL:
    //          - int markUserAlarm(workstationInformation_ logInfo, int userId, int SourceId, int alarmSubtypeId, sTag, sSensorAlarmSubtypeTagId, sNotes, IntHolder alarmId);
    rpc MarkUserAlarm(MarkUserAlarmRequest) returns (NumericResponse);

    //
    // Used to edit user/manual alarm markings data. 
    // TAO IDL:
    //          - int changeUserMarkAlarm(workstationInformation_ logInfo, int alarmId, int userId, String sTag, String sSensorAlarmSubtypeTagId, String notes, boolean isMarkingEnd);
    rpc EditUserMarkAlarm(MarkUserAlarmEditRequest) returns (Response);

    //
    // Returns sensor alarm types. Normally used in the user alarms marking operations.
    // TAO IDL:
    //          - ???????
    // NOTE: probably we need to implement this in the CCTV module or adding a TAO API in the configuration IDL.
    rpc GetSensorAlarmTypes(WorkstationInformation) returns (ListSensorAlarmTypes);

    //
    // Returns sensor alarm subtypes. Normally used in the user alarms marking operations.
    // TAO IDL:
    //          - ???????
    // NOTE: probably we need to implement this in the CCTV module or adding a TAO API in the configuration IDL.
    rpc GetSensorAlarmSubtypes(WorkstationInformation) returns (ListSensorAlarmSubtypes);

    //
    // Returns sensor alarm subtype tags. Normally used in the user alarms marking operations.
    // TAO IDL:
    //          - ???????
    // NOTE: probably we need to implement this in the CCTV module or adding a TAO API in the configuration IDL.
    rpc GetSensorAlarmSubtypesTags(WorkstationInformation) returns (ListSensorAlarmSubtypesTags);









	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Equipments interfaces 
	//

    // 
    // Lock/Unlock equipments, normally cameras. The r
	// NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
	//       is OK, there's' no need to use the specific lock/unlock response item.
    // 
    //  Param:
    //
    //  Returns:
    //
    // TAO IDL: 
    //          - int ping(int IG, int priorityLevel, int[] lockedEquips, int IGTimeout);
    //          - int releaseEquipment(...);
    rpc LockUnlockEquipments(LockUnlockEquipsRequest) returns (MultipleRequestsResponse);

    // 
    // Get ALL locked equipments, normally cameras.
    // TAO IDL: 
    //          - int getLockedEquipments(...);
    rpc GetLockedEquipments(WorkstationInformation) returns (NumericsResponse);

    //
    // From the given list of equipments, obtain all its state.
    // TAO IDL: 
    //          - int getState(int EqId);
    rpc GetEquipmentsGenericState(ListIds) returns (EquipmentsGenericStateResponse);

    //
    // From the given list of equipments, obtain all its specific state.
    // TAO IDL: 
    //          - int getSpecificState(int EqId);
    rpc GetEquipmentsSpecificState(ListIds) returns (EquipmentsSpecificStateResponse);

    //
    // From the given list of equipments, return all its connection information, generic and specific onfiguration
    // TAO IDL: 
    //          - String getGenericConfiguration(int EqId);
    //          - String getSpecificConfiguration(int EqId);
    //          - String getCommunicationSettings(int EqId); TODO: NEEDS IMPLEMENTATION ON THE StvSa!!!!
    rpc GetEquipmentsConfiguration(ListIds) returns (EquipmentsConfigurationResponse);

    //
    // Execute all ptzf cameras presets operations: activate, add, update or delete.
    // TAO IDL:
    //          - int ptzfActivatePreset(int EqId, short nPreset);
    //          - int ptzfStorePreset(workstationInformation_ logInfo, int EqId, short nPreset);
    //          and, for saving the real preset name, call the configuraion.idl API:
    //          - int storePreset(PresetConfigStv_ Preset);
    //          - int ptzfDeletePreset(workstationInformation_ logInfo, int EqId, short nPreset);
    rpc CamerasPtzfPresetsOperation(CameraPtzfSavePresetsRequest) returns (CameraPtzfSavePresetsResponse);

    //
    // Execute all actuator operations: actuate or deactuate.
    // TAO IDL:
    //          - int actuate(workstationInformation_ logInfo, int EqId, int lDuration);
    rpc ExecActuatorOperation(ActuatorOperationsRequest) returns (ActuatorOperationsResponse);










	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Sequences interfaces 
	//

	// Starting sequences in the targets, normally monitors, all given in the StartSeqsInTargetsRequest message.
	// NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
    //       is OK, there's' no need to use the specific target response item.
    // TAO IDL: 
    //          - int setSequenceinTarget(workstationInformation_ logInfo, int SeqID, int TargetID);
	rpc StartSequences(StartSequencesRequest) returns (MultipleRequestsResponse);

	// For all given sequences, executes the given operation: stop, pause, restart and steps forward and backward.
	// NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
    //       is OK, there's' no need to use the specific target response item.
    // TAO IDL:
    //          - int stopSequence(workstationInformation_ logInfo, int SeqHdl);
	//          - int stopAllSequences(workstationInformation_ logInfo, int SeqID);
	//          - int startSequence(workstationInformation_ logInfo, int SeqHdl);
	//          - int pauseSequence(workstationInformation_ logInfo, int SeqHdl);
	rpc ExecSequencesOperation(SequencesOperationRequest) returns (MultipleRequestsResponse);

	// Obtain all running sequences. 
	// The request can be filter by the given WorkStation, targets, sequences handles, etc, 
    // configured in the RunningSequencesRequest parameter, if any.
	// Can be used to obtain:
	//		- all running sequences, if the given parameter is unset; 
	//		- sequences states; 
	//		- which, if any, sequences are active in the given targets;
	//		- etc.    
    // TAO IDL: 
    //          - void getRunningSeqs(...); - returns ALL running sequences which may not be what was requested.
    //          - int getSequenceInTargetData(int targetId, ...);
    //          - int getSequenceInTarget(int targetId);
	rpc GetRunningSequences(RunningSequencesRequest) returns (RunningSequencesResponse);













	/////////////////////////////////////////////////////////////////////////////
	// Macros interfaces 
	//

	// For all given macros, executes the given operation, i.e., start or stop.
	// NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
    //       is OK, there's' no need to use the specific macro response item.
    // TAO IDL: 
    //          - int runMacro(...);
	rpc ExecMacrosOperation(MacrosOperationRequest) returns (MultipleRequestsResponse);

}
	


























































