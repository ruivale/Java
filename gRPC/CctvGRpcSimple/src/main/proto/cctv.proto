/////////////////////////////////////////////////////////////////////////////////////
//  Links:
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/json-transcoding?view=aspnetcore-8.0
//      https://www.infoq.com/articles/dotnet-grpc-json-transcoding/
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/json-transcoding-binding
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/json-transcoding-openapi?view=aspnetcore-8.0
//      https://learn.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-8.0
//      https://cloud.google.com/endpoints/docs/grpc/transcoding
//      https://cloud.google.com/apis/design/naming_convention
//
/////////////////////////////////////////////////////////////////////////////////////

syntax = "proto3";

option csharp_namespace = "Com.Efacec.ES.TRP.Efarail.Cctv.Grpc.v1";
option java_package = "com.efacec.es.trp.efarail.cctv.grpc.v1";

//package com.efacec.es.trp.efarail.cctv.grpc.enums.v1;

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CCTV enums
//
// NOTEs: 
//          - since we're dealing w/ OPEN enums, the first element must be zero (0);
//          - some UNDEF values, which are equal to -1 in the Cctv service, were moved to the end of 
//            the enum values, normally 999. This way, the first elements in those enums are the REAL
//            Cctv service first element, i.e., the value 0 (zero) matching the Cct vservice values.
//

// MsgVersionMod
// Normally used when version are requested
enum VersionMod {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    VERMOD_ALL = 0;
    VERMOD_GRPC = 1;
    VERMOD_SA = 2;
    VERMOD_AGENT = 3;
    VERMOD_PROXY = 4;
}

// SourceObj
// Normally used when target equips connections information is requested.
enum SourceObj {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    SRCOBJ_INVALID = 0;
    SRCOBJ_EQUIP = 1;
    SRCOBJ_SEQUENCE = 2;
    SRCOBJ_REPLAY = 3;
    SRCOBJ_RECORDING = 4;
}

// SequenceOper
// Sequence operations used, only after a sequence as been started, to execute an operation.
enum SequenceOper {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    SEQOPE_STOP = 0;
    SEQOPE_PAUSE = 1;
    SEQOPE_RESTART = 2;
    SEQOPE_STEP_PREVIOUS = 3;
    SEQOPE_STEP_NEXT = 4;
}

// SequenceConfig
// Sequence configuration operations
enum SequenceConfig {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    SEQCONF_ADD = 0;
    SEQCONF_EDIT_BASIC = 1;
    SEQCONF_EDIT_FULL = 2;
    SEQCONF_DELETE = 3;
    SEQCONF_SAVE_OPERATION = 4;
    SEQCONF_DELETE_OPERATION = 5;
}

// SequenceState
// Sequences state type signalling the running sequence actual state.
enum SequenceState {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    SEQSTA_NOT_STARTED = 0;
    SEQSTA_STOP = 1;
    SEQSTA_PLAY = 2;
    SEQSTA_PAUSE = 3;
}

// SequenceMode
// Sequences mode, i.e., ciclic or no ciclic.
enum SequenceMode {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    SEQMOD_UNDEF = 0;
    SEQMOD_CICLIC = 1;
    SEQMOD_NO_CICLIC = 2;
}

// MacroOper
// Macro operation
enum MacroOper {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    MACOPE_START = 0;
    MACOPE_STOP = 1;
}

// ReplyValue
// All possible reply values
enum ResponseValue {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    R_OK = 0;
    R_ERROR = 1;
    R_NOT_IMPLEMENTED = 2;
    R_NOT_SUPPORTED = 3;
    R_INVALID_PARAMETER = 4;
    R_INVALID_EQUIPMENT = 5;
    R_CONFFILE_FAILOPEN = 6;
    R_IPC_CREATION = 7;
    R_IPC_COMMFAIL = 8;
    R_CORBA_EXCEPTION = 9;
    R_DB_ERROR = 10;
    R_DB_NODATABASE = 11;
    R_DB_CONNECTION_TIMEDOUT = 12;
    R_DB_NO_DATA_FOUND = 13;
    R_EQUIP_INITIALIZING = 14;
    R_EQUIP_TERMINATING = 15;
    R_EQUIP_RESETING = 16;
    R_EQUIP_NOTINIT = 17;
    R_EQUIP_ALREADY_INIT = 18;
    R_EQUIP_INVALID_STATE = 19;
    R_EQUIP_NOSTATION = 20;
    R_EQUIP_LOCKED = 21;
    R_EQUIP_PROTO_UNKNOWN = 22;
    R_EQUIP_PROTO_NO_PROTOCOL = 23;
    R_EQUIP_PROTO_TRY_TIMEOUT = 24;
    R_EQUIP_PROTO_SEND_FAIL = 25;
    R_EQUIP_PROTO_FAIL = 26;
    R_EQUIP_PROTO_ACK = 27;
    R_EQUIP_PROTO_ACK_LAST_MSG = 28;
    R_EQUIP_EQ_DATA_UNKNOWN = 29;
    R_EQUIP_EQ_DATA_INCOMPLETE = 30;
    R_EQUIP_EQ_DATA_NOT_OK = 31;
    R_EQUIP_EQ_DATA_OK = 32;
    R_EQUIP_ANSWER_INVALID = 33;
    R_EQUIP_ANSWER_INCOMPLETE = 34;
    R_EQUIP_ANSWER_NOT_OK = 35;
    R_EQUIP_ANSWER_OK = 36;
    R_EQUIP_ANSWER_COMM_ERROR = 37;
    R_EQUIP_CAM_INVALID_PRESET = 38;
    R_EQUIP_MPX_INVALID_CHANNEL = 39;
    R_EQUIP_MPX_INVALID_PAGE = 40;
    R_EQUIP_MATRIX_INVALID_CHANNEL_IN = 41;
    R_EQUIP_MATRIX_INVALID_CHANNEL_OUT = 42;
    R_VC_SERVER_ERROR = 43;
    R_VC_PATH_BROKEN = 44;
    R_VC_PATH_EMPTY = 45;
    R_VC_PATH_BOUND_ERROR = 46;
    R_VC_REFERENCE_ERROR = 47;
    R_VC_OUT_OF_MEMORY = 48;
    R_VC_STATUS_ERROR = 49;
    R_VC_PATH_NOT_FOUND = 50;
    R_VC_SOURCE_ERROR = 51;
    R_VC_TARGET_ERROR = 52;
    R_VC_UNKNOWN_ERROR = 53;
    R_SEQ_ERROR = 54;
    R_SEQ_INVALID_SEQ_ID = 55;
    R_SEQ_NOT_AVALID_SEQUENCE = 56;
    R_SEQ_INVALID_TARGET = 57;
    R_SEQ_COULD_NOT_START = 58;
    R_SEQ_ALREADY_PLAYING = 59;
    R_SEQ_ALREADY_PAUSED = 60;
    R_SEQ_NOT_PLAYING = 61;
    R_SEQ_UNDEF_STATE = 62;
    R_MACRO_ERROR = 63;
    R_MACRO_COULD_NOT_START = 64;
    R_MACRO_NOT_RUNNING = 65;
    R_SCHED_INIT_ERR = 66;
    R_SCHED_SPAWN_ERR = 67;
    R_EQUIP_LOCK_INSUFICIENT_PRIVILEGES = 68;
    R_EQUIP_LOCK_ALREADY_LOCKED = 69;
    R_STATION_UNAVAILABLE = 70;
    R_GENERAL_EXCEPTION = 71;
}

// AlarmType
// All alarm types
enum AlarmType {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    //ALRTYP_UNDEFINED = 0;
    ALRTYP_DB_COMM_FAIL = 0;
    ALRTYP_SA_COMM_FAIL = 1;
    ALRTYP_SA_STATE_CHANGE = 2;
    ALRTYP_SA_INITIALIZE = 3;
    ALRTYP_SA_TERMINATE = 4;
    ALRTYP_SESSION_BEGIN = 5;
    ALRTYP_SESSION_END = 6;
    ALRTYP_OBJ_REF_ERROR = 7;
    ALRTYP_VIDEO_CONNECT_ERROR = 8;
    ALRTYP_VIDEO_SOURCE_INVALID = 9;
    ALRTYP_VIDEO_TARGET_INVALID = 10;
    ALRTYP_VID_SEQ_STATE_CHANGE = 11;
    ALRTYP_MAX_SEQUENCES = 12;
    ALRTYP_MACRO_STATE_CHANGE = 13;
    ALRTYP_SCHEDULED_ACTION_EXECUTED = 14;
    ALRTYP_GUI_COMM_FAIL = 15;
    ALRTYP_STATION_COMM_FAIL = 16;
    ALRTYP_STATION_STATE_CHANGE = 17;
    ALRTYP_EQUIP_COMM_FAIL = 18;
    ALRTYP_EQUIP_STATE_CHANGED = 19;
    ALRTYP_EQUIP_SPECIFIC_STATE_CHANGED = 20;
    ALRTYP_EQUIP_VIDEO_IN_FAIL = 21;
    ALRTYP_EQUIP_VIDEO_OUTF_AIL = 22;
    ALRTYP_IO_ACTIVE = 23;
    ALRTYP_CLOCK_SYNC_ARRIVED = 24;
    ALRTYP_EQUIP_VIDEO_IN_TAMPER = 25;
    ALRTYP_EQUIP_MOTION_DETECTED = 26;
    ALRTYP_VR_NO_SPACE_LEFT = 27;
    ALRTYP_VR_RECORD_FAILURE = 28;
    ALRTYP_VID_SEQ_ADDED = 29;
    ALRTYP_VID_SEQ_REMOVED = 30;
    ALRTYP_VID_SEQ_CHANGE = 31;
    ALRTYP_MACRO_ADDED = 32;
    ALRTYP_MACRO_REMOVED = 33;
    ALRTYP_MACRO_CHANGE = 34;
    ALRTYP_AGENT_COMM_FAIL = 35;
    ALRTYP_EQUIP_LOCK_FAIL = 36;
    ALRTYP_REC_QUALITY_CHANGE = 37;
    ALRTYP_MONITOR_GROUP_CHANGED = 38;
    ALRTYP_AUTO_VIDEO_CONNECT_ERROR = 39;
    ALRTYP_USER_ALARM = 40;
    ALRTYP_REPLAY_STOPED = 41;
    ALRTYP_HQ_REC_QUOTA_EXCEEDED = 42;
    ALRTYP_UNDEFINED = 999;
}

//
// Lock/Unlock equipments 
enum LockUnlockType {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    LCK_LOCK = 0;
    LCK_UNLOCK = 1;
}

//
// The equipments generic state.
enum EquipGenericState {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    //EGS_UNDEF = 0;
    EGS_OK = 0;
    EGS_ERROR = 1;
    EGS_LOCKED = 2;
    EGS_UNDEF = 999;
}

//
// The equipments specific state.
enum EquipSpecificState {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    //ESS_UNDEFINED = 0;
    ESS_CAM_IDLE = 0;
    ESS_CAM_AUTO_PAN = 1;
    ESS_CAM_RESETING = 2;
    ESS_VR_NO_MEDIA = 3;
    ESS_VR_PLAYBACK = 4;
    ESS_VR_RECORD = 5;
    ESS_VR_STOP = 6;
    ESS_VR_PAUSE = 7;
    ESS_VR_FAST_FORWARD = 8;
    ESS_VR_REWIND = 9;
    ESS_VR_REVERSE_PLAY = 10;
    ESS_VR_TIMEDATE_SEARCH = 11;
    ESS_MPX_MULTIPLEX = 12;
    ESS_MPX_FULLSCREEN = 13;
    ESS_MPX_CYCLE = 14;
    ESS_MPX_FREEZE = 15;
    ESS_MPX_VCR = 16;
    ESS_CODEC_DISCONNECTED = 17;
    ESS_CODEC_CONNECTED = 18;
    ESS_CODEC_CONNECTING = 19;
    ESS_CODEC_DISCONNECTING = 20;
    ESS_SENSOR_IDLE = 21;
    ESS_SENSOR_ACTIVE = 22;
    ESS_ACTUATOR_IDLE = 23;
    ESS_ACTUATOR_ACTUATED = 24;
    ESS_ACTUATOR_ACTIVE = 25;
    ESS_WATCHDOG_ENABLED = 26;
    ESS_WATCHDOG_DISABLED = 27;
    ESS_UNDEFINED = 999;
}

//
// The cameras presets oprations.
enum CameraPtzfPresetOperation {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    CPO_ACTIVATE = 0;
    CPO_ADD = 1;
    CPO_UPDATE = 2;
    CPO_DELETE = 3;
}

//
// The actuator operations
enum ActuatorOperation {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    ACO_ACTUATE = 0;
    ACO_DEACTUATE = 1;
}

//
// The user acces type
enum UserAccessType {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    UAT_LOGIN = 0;
    UAT_LOGOUT = 1;
}

// MacrosMode
// Macros mode, i.e., ciclic or no ciclic.
//
// NOTE: THE FIRST ITEM IS -1 IN THE CCTV SERVICE.
//
enum MacroMode {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    MACMOD_CICLIC = 0;
    MACMOD_NO_CICLIC = 1;
}

//
// Macros permissions
enum MacroPermission {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    //MACPER_UNKNOWN = 0;
    MACPER_PRIVATE = 0;
    MACPER_EDIT_EXECUTE = 1;
    MACPER_EXECUTE = 2;
}

//
// Macros scope
enum MacroScope {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    //MACSCP_UNKNOWN = 0;
    MACSCP_ANY = 0;
    MACSCP_MANUAL = 1;
    MACSCP_EVENT = 2;
}

//
// Macros action codes, i.e., the tyoe of macro action.
enum MacroActionCode {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    //MACAC_UNKNOWN = 0;
    MACAC_CAM_SELECT = 0;
    MACAC_MULTIPLEX = 1;
    MACAC_SEQUENCE = 2;
    MACAC_PLAY = 3;
    MACAC_RECORD = 4;
    MACAC_STOP_VR = 5;
    MACAC_ACTUATE = 6;
    MACAC_DEACTUATE = 7;
    MACAC_SLEEP = 8;
    MACAC_DISCONNECT = 9;
    MACAC_SET_STATION_STATE = 10;
    MACAC_MARK_ALARM = 11;
    MACAC_UNKNOWN = 999;
}

//
// The macros configuration operations.
enum MacroConfigOper {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    MACCONFOPER_SAVE = 0;    
    MACCONFOPER_DELETE = 1;
}

//
// The macros generic configuration operations.
enum MacroGenericConfigOper {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    MACGENCONFOPER_ADD = 0;    
    MACGENCONFOPER_SAVE = 1;    
    MACGENCONFOPER_DELETE = 2;
}

//
// The scheduled, equipment and system events reaction configurations type.
enum EventsReactionType {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    ERT_TIMER_SCHEDULED = 0;
    ERT_EQUIPMENT = 1;
    ERT_SYSTEM = 2;
}
//
// The scheduled, equipment and system events reaction configurations operations.
enum EventsReactionConfigOper {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    ERCO_ADD = 0;
    ERCO_SAVE = 1;
    ERCO_DELETE = 2;
}

//
// The scheduled periodicity type.
enum TimerScheduledEventPeriodicityType {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    //SEPT_UNDEF = 0;
    SEPT_ONCE = 0;
    SEPT_HOUR = 1;
    SEPT_DAILY = 2;
    SEPT_WEEK = 3;
    SEPT_UNDEF = 999;
}

//
// The equipments event reaction alarm type;
enum EquipmentEventReactionAlarm {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    EER_UNDEF = 0;
    EER_EQUIP_COMM_FAIL = 19;
    EER_EQUIP_STATE_CHANGED = 20;
    EER_EQUIP_SPECIFIC_STATE_CHANGED = 21;
    EER_EQUIP_VIDEO_IN_FAIL = 22;
    EER_EQUIP_VIDEO_OUTF_AIL = 23;
    EER_IO_ACTIVE = 24;
    EER_CLOCK_SYNC_ARRIVED = 25;
    EER_EQUIP_VIDEO_IN_TAMPER = 26;
    EER_EQUIP_MOTION_DETECTED = 27;
}

//
// The equipments event reaction alarm type;
enum SystemEventReactionAlarm {
    // since we're dealing w/ OPEN enums, the first element must be zero (0);
    SER_UNDEF = 0;
    SER_SA_INITIALIZE = 4;
    SER_SA_TERMINATE = 5;
    SER_SESSION_BEGIN = 6;
    SER_SESSION_END = 7;
    SER_STATION_COMM_FAIL = 17;
    SER_STATION_STATE_CHANGE = 18;
}




























































////////////////////////////////////////////////////////////////////////////////////
//
// CCTV messages
//
//

//
// THE empty message
message Empty {} 

//
// Generic numeric reply
message Response {
    // The numeric value to return to the caller.
    ResponseValue responseValue = 1;
    // A description of the returned value, if needed/wanted (can be left empty).
    string desc = 2;
}

//
// Generic numeric message
message NumericResponse {
    // The numeric value.
    Response response = 1;
    // The numeric response identification
    int64 id = 2;
}

//
// Generic multiple numeric message
message NumericsResponse {
    // The numeric value.
    Response response = 1;
    // The 
    repeated int64 ids = 2;
}

//
// The user message
message User {
    // The user identification
    google.protobuf.Int64Value id = 1;
    // The user name
    google.protobuf.StringValue login = 2;
    // The user name
    google.protobuf.StringValue name = 3;
}

//
// The user access request: login or logout.
message UserAccessRequest {
    // The user identification
    User user = 1;
    // The acces type: login or logout.
    UserAccessType userAccessType = 2;
}

//
// Generic version reply
message CctvVersion {
    // The version value.
    int64 version = 1;
    // The subversion value.
    int64 subVersion = 2;
    // The revision value.
    int64 revision = 3;
    // The build value.
    int64 build = 4;
    // A description of the returned value, if needed/wanted (can be left empty).
    string desc = 5;
    // The module.
    VersionMod versionMod = 6;
}

//
// Generic multiple versions reply
message ListCctvVersionsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The requested modules versions.
    repeated CctvVersion cctvVersions = 2;
}

//
// The current WorkStation information. Normally used by the auditing system.
message WorkstationInformation {
    // The user name of the logged user, i.e., the user login.
    google.protobuf.StringValue userName = 1;
    // The workstation identification.
    google.protobuf.Int64Value id = 2;
    //
    // TODO: should we add the user id?
}

//
// Message used when version are requested.
message VersionsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The requested module.
    VersionMod versionMod = 2;
}

// Basic message holder for connections, i.e., only the source and target data. 
message ConnectionInfo {
    // The source, normally a camera, identification  but could also be a sequence id...
    google.protobuf.Int64Value sourceId = 1;
    // The target equipment, normally a monitor, identification.
    google.protobuf.Int64Value targetId = 2;
}

// Set source in target connection attempts data.
message ConnectionRequest {
    // The basic, i.e. source & target, data.
    ConnectionInfo connectionInfo = 1;
    // The source equipment port (can be left without a value, i.e. 0).
    google.protobuf.Int64Value sourcePort = 2;
    // The target equipment port (can be left without a value, i.e. 0).
    google.protobuf.Int64Value targetPort = 3;
    // Used, if needed to set the address where to connect.
    google.protobuf.StringValue address = 4;
}

//
// Struct used while setting connections between sources equipments, normally cameras
// and targets, normally monitors.
message ConnectionsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // List of connections to attempt.
    repeated ConnectionRequest connectionRequests = 2;
}

//
// Message used when a list of IDs is needed.
message ListIds {
    // The workstation information, if needed.
    WorkstationInformation workstationInfo = 1;
    // Items Ids, whatever tey mean, i.e., sources equipments, targets equipments, 
    // sequences ids, active sequences handles, etc.
    repeated google.protobuf.Int64Value ids = 2;
}
//
// Message used when a list of IDs is needed.
message ListIdsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // Items Ids, whatever tey mean, i.e., sources equipments, targets equipments, 
    // sequences ids, active sequences handles, etc.
    repeated google.protobuf.Int64Value ids = 2;
}

//
// Message used while obtaining targets, normally monitors, connection info. 
// This is not directly used by the Operation service.
message DetailedConnectionInfo {
    // The target identification.
    int64 targetId = 1;
    // The type of active source in a target.
    SourceObj sourceObj = 2;
    // Additional info for SourceObj.REPLAY type.
    int64 handle = 3;
    // The source identification i.e,, an equipment id, a sequence id, etc.
    int64 sourceId = 4;
    // The source station identification when available/used/set.
    int64 stationId = 5;
    // The recorder source identification when available/used/set.
    int64 recorderSourceId = 6;
}

//
// Message used while obtaining targets, normally monitors, connection info.
message DetailedConnectionsInfoResponse {
    // The request reply.
    Response response = 1;
    // the list of targets connection information.
    repeated DetailedConnectionInfo detailedConnectionInfos = 2;
}

//
// Return message when multiple requests are sent in a single invocation.
message MultipleRequestsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response globalResponse = 1;
    // The list of IDs and request status of each one of them. 
    // NOTE: if the globalReply is OK, there no need to use this item.
    repeated NumericResponse specificResponses = 2;
}

//
// Information associated to a sequence start.
message SequenceConnInfo {
    // The connection info, i.e., sequence, the source item in the message, and target.
    ConnectionInfo connectionInfo = 1;
    // Used for syncronous sequences. Values from 0..30, in intervals of 5 meaning seconds.
    // NOTE: nowadays, @2406, not used anymore... but here just in case
    google.protobuf.StringValue syncTime = 2;
}

//
// The sequences starting command request.
message StartSequencesRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The sequences information.
    repeated SequenceConnInfo sequenceConnInfos = 2;
}

//
// The sequence basic information, normally used to define a sequence but NOT a running one.
message Sequence {
    // The sequence identification.
    int64 id = 1;
    // The sequence name.
    string name = 2;
    // The sequence mode: undefined, ciclic or non ciclic.
    SequenceMode mode = 3;
}

//
// Reply message when all sequences are requested.
message ListSequencesResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // All the sequences
    repeated Sequence sequences = 2;
}

//
// The running sequence data holder.
message RunningSequence {
    // The sequence identification. 
    // May not be needed if the handle is set. It can be useful, but not always mandatory.
    google.protobuf.Int64Value id = 1;
    // The running sequence handle, i.e., the running sequence identification.
    google.protobuf.Int64Value handle = 2;
    // The running sequence active target, normally not needed but can be sent just in case.
    google.protobuf.Int64Value targetId = 3;
    // The sequence state. Depending on the operation, this value could be not set.
    SequenceState state = 4;
    // Used for syncronous sequences. Values from 0..30, in intervals of 5 meaning seconds.
    // NOTE: nowadays, @2406, not used anymore... but here just in case.
    google.protobuf.Int64Value syncTime = 5;
}

//
// The running sequences data holder.
message RunningSequencesRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The running sequencse handles, i.e., the running sequence identification
    repeated RunningSequence runningSequences = 2;	
}

//
// The running sequence reply message.
message RunningSequenceResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The running sequence handle and target
    RunningSequence runningSequence = 2;
    // The running sequence state, i.e., one from SequenceOper (When )
    SequenceOper SequenceOper = 3;
}

//
// The running sequences reply message, normally used when obtaining all running sequences.
message RunningSequencesResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The running sequences reply message
    repeated RunningSequenceResponse runningSequencesResponse = 2;
}

//
// Used when stopping, pausing, restarting sequences. 
// Only a single SequenceOper can be applied to the given list of sequences or targets.
message SequencesOperationRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The sequence oper: stop, pause, restart, next or previous step.
    SequenceOper sequenceOper = 2;
    // Items Ids, whatever they mean, i.e., targets equipments or sequences handles 
    // depending on the set prop from MsgRunningSequence.
    repeated RunningSequence runningSequences = 3;
}

//
// Return message when multiple requests are sent in a single macro operation invocation.
message MacroOperationResponse {
    // Specific response
    Response response = 1;
    // The macro identification.
    int64 macroId = 2;
    // The macro operation handle. Used when a start/run macro is used/called.
    int64 macroHandle = 3;
}

//
// Return message when multiple requests are sent in a single invocation.
message MacroOperationsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response globalResponse = 1;
    // The list of macros ids and its handle if the request was for a start/run macro.
    // NOTE: if the globalReply is OK, there no need to use this item.
    repeated MacroOperationResponse macroOperationsResponses = 2;
}

//
// Used to start and stop macros. 
// Only a single MacroOper can be applied to the given list of macros.
message MacrosOperationRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The macro oper, i.e., start or stop.
    MacroOper macroOper = 2;
    // Macros Ids.
    repeated google.protobuf.Int64Value ids = 3;
}

//
// Alarm information.
message Alarm {
    // The alarm identification
    AlarmType type = 1;
    // The alarm parameters
    string params = 2;
    // The alarm equipment identification, if any.
    int64 equipmentId = 3;
    // The alarm station identification, if any.
    int64 stationId = 4;
    // The alarm trigger, if any.
    int64 trigger = 5;
}

//
// List of alarms, normally used when obtaing the list of ALL active alarms.
message ListAlarms {
    // The list of alarms.
    repeated Alarm alarms = 1;
}

//
// List of alarms, normally used when obtaining the list of ALL active alarms.
message ListAlarmsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of alarms.
    repeated Alarm alarms = 2;
}

//
// Message used when a lock, or unlock, equipments request is invoked.
message LockUnlockEquipsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The list of identifications, normally from cameras.
    repeated google.protobuf.Int64Value ids = 2;
    // The lock or unlock Operation.
    LockUnlockType lockUnlockType = 3;
    // The operation priority (normally associated w/ user profile priority)
    google.protobuf.Int64Value priority = 4;
    // The lock timeout. If, before this timeout ends, Cctv does not receive further locks, the locks ends.
    google.protobuf.Int64Value timeout = 5;
}

//
// Equipment generic state.
message EquipmentGenericState {
    // The equipment identification
    int64 equipId = 1;
    // The generic state.
    EquipGenericState equipGenericState = 2;
}

//
// The equipments generic state response.
message EquipmentsGenericStateResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    //
    repeated EquipmentGenericState equipmentGenericStates = 2;
}

//
// Equipment specific state.
message EquipmentSpecificState {
    // The equipment identification
    int64 equipId = 1;
    // The generic state.
    EquipSpecificState equipSpecificState = 2;
}

//
// The equipments specific state response.
message EquipmentsSpecificStateResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    //
    repeated EquipmentSpecificState equipmentSpecificStates = 2;
}

//
// An equipment associated data.
message Equipment {
    // The equipment identification.
    google.protobuf.Int64Value id = 1;
    // The equipment name.
    google.protobuf.StringValue name = 2;
    // The equipment type.
    google.protobuf.Int64Value type = 3;
    // Is the equipment enabled?
    google.protobuf.BoolValue enabled = 4;
    // The equipment station identification.
    google.protobuf.Int64Value stationId = 5;
    // The equipment communications settings.
    google.protobuf.StringValue commSettings = 6;
    // The equipment generic state.
    EquipGenericState genericState = 7;
    // The equipment specific state.
    EquipSpecificState specificState = 8;
    // The equipment generic configuration.
    google.protobuf.StringValue genericConfig = 9;
    // The equipment specific configuration.
    google.protobuf.StringValue specificConfig = 10;
    // The equipment associated box identification, if any.
    google.protobuf.Int64Value boxId = 11;
}

//
// The equipments response.
message ListEquipmentsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of equipments.
    repeated Equipment equipments = 2;
}

//
// An equipment associated data.
message EquipmentConfiguration {
    // The equipment identification.
    google.protobuf.Int64Value id = 1;
    // The equipment communications settings.
    google.protobuf.StringValue commSettings = 2;
    // The equipment generic configuration.
    google.protobuf.StringValue genericConfig = 3;
    // The equipment specific configuration.
    google.protobuf.StringValue specificConfig = 4;
}

//
// The equipments configuration response.
message EquipmentsConfigurationResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    //
    repeated EquipmentConfiguration equipmentConfigurations = 2;
}

//
// A camera preset CRUD operation message.
message CameraPtzfPreset {
    // The camera identification.
    google.protobuf.Int64Value cameraId = 1;
    // The ptzf camera preset slot index.
    google.protobuf.Int64Value index = 2;
    // The ptzf camera preset name.
    google.protobuf.StringValue name = 3;
}

//
// The cameras preset CRUD operations request.
message CameraPtzfSavePresetsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The camera identification.
    repeated CameraPtzfPreset cameraPtzfPresets = 2;
    // The request operation: add, update and delete
    CameraPtzfPresetOperation cameraPtzfPresetOperation = 3;
}

//
// The cameras preset CRUD operation response.
message CameraPtzfSavePresetResponse {
    // The response.
    Response response = 1;
    // The camera preset saving information.
    CameraPtzfPreset cameraPtzfPreset = 2;
}

//
// The cameras preset CRUD operations request.
message CameraPtzfSavePresetsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of saving cameras presets responses.
    repeated CameraPtzfSavePresetResponse cameraPtzfSavePresetResponses = 2;
}

//
// The actuator operation: actuate or deactuate.
message ActuatorOperationRequest {
    // The actuator identification.
    google.protobuf.Int64Value actuatorId = 1;
    // The actuator operation.
    ActuatorOperation actuatorOperation = 2;
}

//
// The actuator operations request.
message ActuatorOperationsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The list of actuator operations.
    repeated ActuatorOperationRequest actuatorOperationRequests = 2;
}

//
// Single actuator operation request response.
message ActuatorOperationResponse {
    // The response.
    NumericResponse response = 1;
    // The actuator operation.
    ActuatorOperation actuatorOperation = 2;
}

//
// Actuators operations requests response.
message ActuatorOperationsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The response.
    repeated ActuatorOperationResponse actuatorOperationResponses = 2;
}

//
// The "Not Acknowledged Alarm".
message NotAcknowledgedAlarm {
    // The associated monitors list identification.
    int64 groupId = 1;
    // The monitor identification (of course, the given monitor identification, if valid, must be a monitor "belonging" to the group set. ).
    int64 monId = 2;
    // The not acknowledged alarm identification.
    int64 alarmId = 3;
    // The not acknowledged alarm position "inside" the alarms stack list.
    int64 pos = 4;
    // The not acknowledged alarm description.
    string description = 5;
    // The not acknowledged alarm source equipment identification, normally pointing to a camera.
    int64 sourceId = 6;
    // The not acknowledged alarm source equipment, normally a camera, preset, if set and if the camera is a PTZ one.
    int64 prePos = 7;
}

//
// The acknowledge alarms response, which, basicaly, is the new list of NotAcknowledgeAlarms.
message AcknowledgeAlarmsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    //
    repeated NotAcknowledgedAlarm notAcknowledgedAlarms = 2;
}

//
// The "Set Alarms On Monitor" connection request. 
message AlarmMonitorConnectionInfo {
    // if true, the operation is directed to a monitor in a group, aka alarm monitor.
    google.protobuf.BoolValue monitorInGroup = 1;
    // the source & target info.
    ConnectionInfo connectionInfo = 2;
}

//
// The "Set Alarms On Monitor" request. Basically is a list of NotAcknowledgeAlarms identifications and target equipments, normally monitors, identifications.
message SetAlarmsOnMonitorRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The connections info, i.e., source and target identifications pairs.
    repeated AlarmMonitorConnectionInfo connectionInfos = 2;
}

//
// The mark an user alarm message associated with the given source identification. 
message MarkUserAlarmRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The user identification.
    google.protobuf.Int64Value userId = 2;
    // The source equipment identification.
    google.protobuf.Int64Value equipId = 3;
    // The alarm sub type identification. (from STV DB. t_sensoralarmsubtypes)
    google.protobuf.Int64Value alarmSubtypeId = 4;
    // The marking parameters. (from STV DB: t_sensralarsubtypes_tags_parms)
    google.protobuf.StringValue param = 5;
    // The marking subtype tag id of the sensor. (from STV DB: t_sensoralarmsubtypes_tags)
    google.protobuf.StringValue alarmSensorSubtypeTagId = 6;
    // The marking notes. (from STV DB: t_video_recalarm_params)
    google.protobuf.StringValue notes = 7;
}

//
// A sensor alarm type.
message SensorAlarmType {
    // The sensor alarm type identifiction.
    int64 id = 1;
    // The sensor alarm type description.
    string description = 2;
}

//
// A list of sensor alarm types.
message ListSensorAlarmTypes {
    // The list of SensorAlarmType.
    repeated SensorAlarmType sensorAlarmTypes = 1;
}

//
// A list of sensor alarm types.
message ListSensorAlarmTypesResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of SensorAlarmType.
    repeated SensorAlarmType sensorAlarmTypes = 2;
}

//
// A sensor alarm subtype.
message SensorAlarmSubtype {
    // The sensor alarm type identifiction.
    int64 id = 1;
    // The sensor alarm type description.
    string description = 2;
    // The sensor alarm type.
    SensorAlarmType sensorAlarmType = 3;
    // Indicates if the sensor alarm subtype can be searchable in any searchable GUI.
    bool guiSearchable = 4;
    // The sensor alarm subtype priority.
    int64 priority = 5;
}

//
// A list of sensor alarm subtypes.
message ListSensorAlarmSubtypes {
    // The list of SensorAlarmSubtype.
    repeated SensorAlarmSubtype sensorAlarmSubtypes = 1;
}

//
// A list of sensor alarm subtypes.
message ListSensorAlarmSubtypesResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of SensorAlarmSubtype.
    repeated SensorAlarmSubtype sensorAlarmSubtypes = 2;
}

//
// A sensor alarm subtype tag.
message SensorAlarmSubtypesTag {
    // The sensor alarm type identifiction.
    int64 id = 1;
    // The sensor alarm subtype tag description.
    string description = 2;
    // The sensor alarm subtype tag name.
    string name = 3;
    // True if the sensor alarm subtype tag needs parameters when used.
    bool hasParameters = 4;
    // True if the sensor alarm subtype tag allows for notes to be added when used.
    bool allowNotes = 5;
    // The sensor alarm subtype tag associated subtype.
    SensorAlarmSubtype sensorAlarmSubtype = 6;
    // Trie if the sensor alarm subtype tag is te default one in the system.
    bool default = 7;
}

//
// A list of sensor alarm subtype tags.
message ListSensorAlarmSubtypesTags {
    // The list of SensorAlarmSubtype.
    repeated SensorAlarmSubtypesTag sensorAlarmSubtypesTags = 1;
}

//
// A list of sensor alarm subtype tags.
message ListSensorAlarmSubtypesTagsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of SensorAlarmSubtype.
    repeated SensorAlarmSubtypesTag sensorAlarmSubtypesTags = 2;
}



//
// The message used to edit an already user/manual alarm marking.
message MarkUserAlarmEditRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The alarm identification.
    google.protobuf.Int64Value alarmId = 2;
    // The user identification.
    google.protobuf.Int64Value userId = 3;
    // The marking tag parameter. 
    google.protobuf.StringValue tag = 4;
    // The marking subtype tag id of the sensor. 
    google.protobuf.StringValue alarmSensorSubtypeTagId = 5;
    // The marking notes. (from STV DB: t_video_recalarm_params)
    google.protobuf.StringValue notes = 6;
    // If true it means the marking just occurred. False for all other usages.
    google.protobuf.BoolValue markingEnd =  7;
}

//
// The "normal" acknowledge alarms message, Normally used to acknowledge sensors and actuators alarms.
message AckAlarmsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The equipment identification.
    google.protobuf.Int64Value equipId = 2;
    // The list os alarms to acknowledge.
    repeated google.protobuf.Int64Value alarmIds = 3;
}

//
// A PTZF operation associated info. Used when a PTZF camera is PTZFed, i.e., moved, 
// and it supports the "Return to Home Position" feature.
// Its used for configuration and operation (reset/restart the "Go to Home Position" timer).
message MobileCameraAutoHomePositionActivation {
    // The camera identification.
    google.protobuf.Int64Value camId = 1;
    // If true it means the camera has the "Go To Home Position" feature enabled.
    google.protobuf.BoolValue enabled =  2;
    // The "Return to Home Position" timeout, i.e., the ammount of seconds before moving 
    // the camera to its configured home position after the last PTZF operation was performed.
    google.protobuf.Int64Value timeout = 3;
    // The camera preset index used to set the home position.
    google.protobuf.Int64Value preset = 4;
    // True if the home position is set by a PreSet, 
    // false if the home position is set by a pre-configured value (stored in T_OPTIONSSTV [PRESETS_HOME oprtion]).
    google.protobuf.BoolValue hasHomePosSet =  5;
    // If 1 (true), a sequence start will disable the feature for the camera until the sequence is stopped (the camera must be present in the sequence list of operations).
    google.protobuf.BoolValue sequenceMng =  6;
    // If 1 (true), a alarm reaction, which has the camera in its associated macro actions, will disable the feature. For it to be enabled again, the user must start it.
    google.protobuf.BoolValue alarmMng =  7;
}

//
// The "Go to Home Position" oper/config request message.
message MobileCameraAutoHomePositionActivationsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The PTZF operations.
    repeated MobileCameraAutoHomePositionActivation mobileCameraAutoHomePositionActivations = 2;
}

//
// The list of PtzfOperation.
message ListMobileCameraAutoHomePositionActivations {
    // The list of PtzfOperations.
    repeated MobileCameraAutoHomePositionActivation mobileCameraAutoHomePositionActivations = 1;
}

//
// The list of PtzfOperation.
message ListMobileCameraAutoHomePositionActivationsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of PtzfOperations.
    repeated MobileCameraAutoHomePositionActivation mobileCameraAutoHomePositionActivations = 2;
}

//
// The Cctv agent data.
message Agent {
    // The agent identification.
    int64 id = 1;
    // The agente address.
    string address = 2;
    // True if the agent is enabled.
    bool enabled = 3;
    // The agent server identification.
    int64 serverId = 4;
}

//
// The Cctv station.
message Station {
    // The station identification.
    int64 id = 1;
    // The station name.
    string name = 2;
    // The station status.
    int64 status = 3;
    // True if the station is enabled.
    bool enabled = 4;
    // The station polling timeout. (?????)
    int64 pollingTimeout = 5;
    // The station identification
    int64 type = 6;
}

//
// The Cctv equipment class.
message EquipmentClass {
    // The equipment class identification.
    int64 id = 1;
    // The equipment class name.
    string name = 2;
    // The equipment class generic configuration sintaxe.
    string sxGenericConfig = 3;
}

//
// The Cctv equipment type.
message EquipmentType {
    // The equipment type identification.
    int64 id = 1;
    // The equipment type name.
    string name = 2;
    // The equipment type class identification.
    int64 classId = 3;
    // The equipment type generic configuration.
    string genericConfig = 4;
    // The equipment type specific configuration.
    string specificConfig = 5;

//    // The equipment type communication settings.
//    string commSettings = n;
//    // The equipment type video terminals.
//    string videoTerminals = n;
//    // The equipment type driver.
//    string driver = n;
}

//
// An Cctv agent configuration and the network data: agent, stations, equipment classes, equipment types and equipments.
message CctvConfig {
    // The agent configuration.
    Agent agent = 1;
    // The agent stations.
    repeated Station stations = 2;
    // The agent equipment classes.
    repeated EquipmentClass equipmentClasses = 3;
    // The agent equipment types.
    repeated EquipmentType equipmentTypes = 4;
    // The agent equipments.
    repeated Equipment equipments = 5;
}

//
// The Cctv basic network configuration grouped by Cctv agents.
message CctvConfigResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The workstation information.
    WorkstationInformation workstationInfo = 2;
    // The agents configurations.
    repeated CctvConfig cctvConfigs = 3;
}

//
// The sequences operation. Basically holds info about a sequence iteraction.
message SequenceOperation {
    // 
    google.protobuf.Int64Value sequenceId = 1;
    // 
    google.protobuf.Int64Value position = 2;
    // 
    google.protobuf.BoolValue enabled = 3;
    // 
    google.protobuf.Int64Value equipmentId = 4;
    // 
    google.protobuf.StringValue equipmentParam = 5;
    // 
    google.protobuf.Int64Value duration = 6;
}

//
// The sequence configuration message.
message SequenceFullData {
    // The basic sequence data: identification, name and mode.
    Sequence sequence = 1;
    // The list of sequence operations, i.e., its iteractions.
    repeated SequenceOperation sequenceOperations = 2;
}

//
// The sequence basic info and its operations.
message ListSequenceFullData {
    // The list of complete sequnce data, i.e., its basic data and its operations.
    repeated SequenceFullData sequenceFullDatas = 1;
}

//
// The sequence basic info and its operations.
message ListSequenceFullDataResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of complete sequnce data, i.e., its basic data and its operations.
    repeated SequenceFullData sequencesFullData = 2;
}

//
// The sequences configurations request.
message SequenceConfigRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The sequence configuration operation: add, basic edit, full edit and delete.
    SequenceConfig sequenceConfig = 2;
    // The sequences configurations to perform.
    repeated SequenceFullData sequencesFullData = 3;
}

//
// The sequences configurations responses.
message SequenceConfigResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The SequenceConfigurations which were not correctly configured. The ones that went well are absent from this list.
    repeated ListSequenceFullDataResponse sequencesFullDataResponse = 2;
}



//
// A macro action parameter.
message MacroActionParameter {
    // The associated macro identification.
    google.protobuf.Int64Value macroId = 1;
    // The associated macro action number/index.
    google.protobuf.Int64Value actionIdx = 2;
    // The associated macro action parameter number/index.
    google.protobuf.Int64Value paramIdx = 3;
    // The associated macro action parameter value.
    google.protobuf.StringValue value = 4;
}

//
// A list of macro action parameters.
message ListMacroActionParameter {
    repeated MacroActionParameter macroActionParameters = 1;
}

//
// A list of macro action parameters.
message ListMacroActionParameterResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of macro actions parameters.
    repeated MacroActionParameter macroActionParameters = 2;
}

//
// The macro action data.
message MacroAction {
    // The associated macro identification.
    google.protobuf.Int64Value macroId = 1;
    // The associated macro identification.
    google.protobuf.Int64Value actionIdx = 2;
    // The associated macro action code identification.
    MacroActionCode macroActionCode = 3;
    // True is the macro action is enabled.
    google.protobuf.BoolValue enabled = 4;
}

//
// A macro action data and its parameters.
message MacroActionFullData {
    // The macro action
    MacroAction macroAction = 1;
    // The macro action parameters.
    repeated MacroActionParameter macroActionParameters = 2;
}

//
// The base macro data.
message Macro {
    // The macro identification.
    google.protobuf.Int64Value id = 1;
    // The macro name.
    google.protobuf.StringValue name = 2;
    // The macro mode.
    MacroMode mode = 3;
    // The user/owner which added the macro.
    google.protobuf.Int64Value ownerId = 4;
    // The macro permission: unknown, private, edit & execute and execute.
    MacroPermission permission = 5;
    // The macro scope: unknown, any, manual and event.
    MacroScope scope = 6;
    // True means the macro can be edited. Normally true when the macro owner is the same 
    // has the user configuring the macro or if the macro permission is "Edit & Execute";
    google.protobuf.BoolValue canEdit = 7;
    // If true, means the macro does not send a notification when it starts.
    google.protobuf.BoolValue silent = 8;
}

//
// The macro basic data, all its actions and the all actions parameters.
message MacroFullData {
    // The basic macro data.
    Macro macro = 1;
    // The macros actions and all its parameters.
    repeated MacroActionFullData macroActionFullDatas = 2;
}

//
// The request message when trying to obtain macros, filtered or not, configuration data.
message MacrosRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The macro identification. If its an invalid value, it means there's no filter for macro x, i.e., all macros configurations should be returned.
    google.protobuf.Int64Value id = 2;
    // The user/owner which added the macro. If its an invalid value, it means there's no owner id filter set so, should return all macros configurations.
    google.protobuf.Int64Value ownerId = 3;
}

//
// The request message when trying to obtain macros, filtered or not, configuration data.
message MacroActionParametersRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The macro identification. If its an invalid value, it means there's no filter for macro x, i.e., all macros configurations should be returned.
    google.protobuf.Int64Value macroId = 2;
    // The macro action index. If its an invalid value, it means there's no filter for macro action index actionIdx.
    google.protobuf.Int64Value actionIdx = 3;
}

//
// The list of macros full data, i.e., macros, its actions and its actions parameters.
message ListMacrosFullData {
    // The list of macros.
    repeated MacroFullData macroFullDatas = 1;
}

//
// The list of macros full data, i.e., macros, its actions and its actions parameters.
message ListMacrosFullDataResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of macros.
    repeated MacroFullData macroFullDatas = 2;
}

//
// The list of macros.
message ListMacros {
    // The list of macros.
    repeated Macro macros = 1;
}

//
// The list of macros.
message ListMacrosResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of macros.
    repeated Macro macros = 2;
}

//
// The message used when a macro actions are requested.
message MacroActionsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The macro identification. If its an invalid value, it means there's no filter for macro x, i.e., all macros configurations should be returned.
    google.protobuf.Int64Value macroId = 2;
}

//
// A list of macro action parameters.
message ListMacroActions {
    // The list of macro actions.
    repeated MacroAction macroActions = 1;
}

//
// A list of macro action parameters.
message ListMacroActionsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of macro actions.
    repeated MacroAction macroActions = 2;
}

//
// The message used to configure macro action(s).
message MacroActionConfigurationRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The operation: save or delete.
    MacroConfigOper macroConfigOper = 2;
    // The list of action. If it's a save action operation, a full action and parameters save operation 
    // or a delete one, we can obtain all the data from the given list of MacroAction.
    repeated MacroActionFullData macroActionFullDatas = 3;
}

//
// The message used to configure macro action(s).
message MacroActionConfigurationResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The MacroAction which were not correctly configured. The ones that went well are absent from this list.
    repeated MacroAction macroActions = 2;
}

//
// The macros configurations request.
message MacroConfigurationRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The operation: add, save or delete.
    MacroGenericConfigOper macroGenericConfigOper = 2;
    // The macros complete list of data.
    repeated MacroFullData macroFullData = 3;
}

//
// The macros configurations response.
message MacroConfigurationResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The MacroFullData which were not correctly configured. The ones that went well are absent from this list.
    repeated MacroFullData macroFullDatas = 2;
}

//
// The message used to obtain cameras presets.
message CamerasPresetsRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The list of cameras identifications.
    repeated google.protobuf.Int64Value cameraIds = 2;
}

//
// The message used when cameras presets are requested. 
message CamerasPresetsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of cameras presets.
    repeated CameraPtzfPreset cameraPtzfPresets = 2;
}

//
// The cameras presets basic edition request (i.e., the STV DB data edition only)
message CamerasPresetsEditionRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The list of cameras presets.
    repeated CameraPtzfPreset cameraPtzfPresets = 2;
}

//
// The cameras presets basic edition request response (i.e., the STV DB data edition only)
message CamerasPresetsEditionResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of cameras presets which were not correctly configured. The ones that went well are absent from this list.
    repeated CamerasPresetsResponse cameraPtzfPresetsResponses = 2;
}

//
// An events reaction i18n message data. 
message I18nMessage {
    // The i18n message language, like: en_GB, pt_PT, nb_NO, etc.
    google.protobuf.StringValue lang = 1;
    // The message itself.
    google.protobuf.StringValue message = 2;
}

//
// The equipment and system event reaction data.
message EquipmentOrSystemEventReaction {
    // The event identification.
    google.protobuf.Int64Value id = 1;
    // The event description.
    google.protobuf.StringValue description = 2;
    // The event reaction configured i18n messages.
    repeated I18nMessage i18nMessages = 3;
    // True if the event reaction is enabled.
    google.protobuf.BoolValue enabled = 4;
    // The reaction parameters.
    google.protobuf.StringValue params = 5;
    // The reaction associated macro identification.
    google.protobuf.Int64Value macroId = 6;
}

//
// The equipment event reaction data.
message EquipmentEventReaction {
    // The basic equipment event reaction data.
    EquipmentOrSystemEventReaction equipmentOrSystemEventReaction = 1;
    // The equipment event reaction alarm type.
    EquipmentEventReactionAlarm equipmentEventReactionAlarm = 2;
}

//
// The system event reaction data.
message SystemEventReaction {
    // The basic system event reaction data.
    EquipmentOrSystemEventReaction equipmentOrSystemEventReaction = 1;
    // The system event reaction alarm type.
    SystemEventReactionAlarm systemEventReactionAlarm = 2;
}

//
// The message used to return all equipment event reactions.
message EquipmentEventReactionResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The equipment event reaction.
    EquipmentEventReaction equipmentEventReaction = 2;
}

//
// The message used to return all equipment event reactions.
message EquipmentEventReactionsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of equipment event reactions.
    repeated EquipmentEventReaction equipmentEventReactions = 2;
}

//
// The message used to return all system event reactions.
message SystemEventReactionResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The system event reaction.
    SystemEventReaction systemEventReaction = 2;
}

//
// The message used to return all system event reactions.
message SystemEventReactionsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of system event reactions.
    repeated SystemEventReaction systemEventReactions = 2;
}

//
// The equipment event reactions configuration request.
// If it's a save and the EquipmentEventReaction.EquipmentOrSystemEventReaction.id 
// is an invalid one, it means it's an addition; otherwise it will be treated as an edition.
message EquipmentEventReactionsConfigurationRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The type of configuration operation: save or delete.
    EventsReactionConfigOper eventsReactionConfigOper = 2;
    // The list of equipment event reactions to process.
    repeated EquipmentEventReaction equipmentEventReactions = 3;
}

//
// The system event reactions configuration request.
// If it's a save and the EquipmentEventReaction.EquipmentOrSystemEventReaction.id 
// is an invalid one, it means it's an addition; otherwise it will be treated as an edition.
message SystemEventReactionsConfigurationRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The type of configuration operation: save or delete.
    EventsReactionConfigOper eventsReactionConfigOper = 2;
    // The list of equipment event reactions to process.
    repeated SystemEventReaction systemEventReactions = 3;
}

//
// The equipment event reactions configuration request response.
message EquipmentEventReactionsConfigurationResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of equipment event reactions which were not correctly configured. The ones that went well are absent from this list.
    repeated EquipmentEventReactionResponse equipmentEventReactionsResponses = 2;
}

//
// The system event reactions configuration request response.
message SystemEventReactionConfigurationResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The system event reaction which was not correctly configured.
    SystemEventReaction systemEventReaction = 2;
}

//
// The system event reactions configuration request response.
message SystemEventReactionsConfigurationResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of system event reactions which were not correctly configured. The ones that went well are absent from this list.
    repeated SystemEventReactionResponse systemEventReactionsResponses = 2;
}

//
// The timer scheduled event reaction data.
message TimerScheduledEventReaction {
    //
    google.protobuf.Int64Value id = 1;
    //
    google.protobuf.StringValue description = 2;
    //
    google.protobuf.BoolValue enabled = 3;
    //
    google.protobuf.Int64Value day = 4;
    //
    google.protobuf.Int64Value month = 5;
    //
    google.protobuf.Int64Value year = 6;
    //
    google.protobuf.Int64Value hour = 7;
    //
    google.protobuf.Int64Value minute = 8;
    //
    TimerScheduledEventPeriodicityType timerScheduledEventPeriodicityType = 9;
    //
    google.protobuf.Int64Value macroId = 10;
}

//
// The message used to return all timer scheduled event reactions.
message TimerScheduledEventReactionResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The timer scheduled event reactions.
    TimerScheduledEventReaction timerScheduledEventReaction = 2;
}

//
// The message used to return all timer scheduled event reactions.
message TimerScheduledEventReactionsResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of timer scheduled event reactions.
    repeated TimerScheduledEventReaction timerScheduledEventReactions = 2;
}

//
// The timer scheduled event reactions configuration request.
// If it's a save and the TimerScheduledEventReaction.id is an invalid one, 
// it means it's an addition; otherwise it will be treated as an edition.
message TimerScheduledEventReactionsConfigurationRequest {
    // The workstation information.
    WorkstationInformation workstationInfo = 1;
    // The type of configuration operation: save or delete.
    EventsReactionConfigOper eventsReactionConfigOper = 2;
    // The list of timer scheduled event reactions to process.
    repeated TimerScheduledEventReaction timerScheduledEventReactions = 3;
}

//
// The timer scheduled event reactions configuration request response.
message TimerScheduledEventReactionsConfigurationResponse {
    // Global reply for the request. If this is OK, then ALL requests were successful. 
    Response response = 1;
    // The list of timer scheduled event reactions which were not correctly configured. The ones that went well are absent from this list.
    repeated TimerScheduledEventReactionResponse timerScheduledEventReactionsResponses = 2;
}





































































////////////////////////////////////////////////////////////////////////////////////
//
// CCTV operation interface (TAO IDL: operation.idl)
//
//
service Operation {

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Generic operations
    //

    //
    // Signals the CCTV service an user just logged in or out.
    // TAO IDL:
    //          - void userAccess(short type, int userId);
    rpc UserAccess(UserAccessRequest) returns (Response);

    // Obtain the Operation service version
    // TAO IDL:
    //          - void getAgentVersions(...);
    //          - void getStvSaVersion(...);
    rpc GetVersions(VersionsRequest) returns (ListCctvVersionsResponse);

    // Obtains the given targets connection information, if any.
    // TAO IDL: 
    //          - int getSourcesInTargets(int[] targets, ...);
    rpc GetDetailedConnectionsInfo(ListIds) returns (DetailedConnectionsInfoResponse);
    
    // Setting connections between source equipments, normally cameras, and targets, normally monitors.
    // NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
    //       is OK, there's no need to use the specific target response item.
    // TAO IDL: 
    //          - int setSourceinTarget(...);
    rpc Connect(ConnectionsRequest) returns (MultipleRequestsResponse);

    // Disconnects all the given targets. Returns a list of results for each given target.
    // NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
    //       is OK, there's no need to use the specific target response item.
    // TAO IDL: 
    //          - int disconnectVideoFromTarget(workstationInformation_ logInfo, int targetId);
    //          - int disconnectVideoFromTargetEx(workstationInformation_ logInfo, int[] targetIds, ...);
    //          or w/ source id set to -1 (i.e., invalid id):
    //          - int setSourceinTarget(workstationInformation_ logInfo, -1, int TargetID, 1, 1);
    rpc Disconnect(ListIds) returns (MultipleRequestsResponse);

    //
    // Obtain ALL active alarms.
    // TAO IDL: 
    //          - void getAlarms(...);
    rpc GetAlarms(WorkstationInformation) returns (ListAlarmsResponse);

    //
    // Normally used to acknowledge sensors and actuators alarms.
    // TAO IDL:
    //          - int ackAlarm(workstationInformation_ logInfo, int nEquipId, int[] listAlarmIds, ...);
    rpc AckAlarms(AckAlarmsRequest) returns (MultipleRequestsResponse);







    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Groups of monitor, aka, alarm stack.

    //
    // Method used to acknowledge alarms in the alarms monitor list.
    // TAO IDL:
    //          - int acknowledgeAlarms(workstationInformation_ logInfo, long[] ackAlarms, listNotAckAlarmsHolder alarms);
    rpc AcknowledgeAlarmsInAlarmStack(ListIds) returns (AcknowledgeAlarmsResponse);

    //
    // Returns all NotAcknowledgedAlarms. Related w/ groups of monitors.
    // TAO IDL:
    //          - int getNotAckAlarms(...);
    rpc GetNotAcknowledgedAlarmsInAlarmStack(WorkstationInformation) returns (AcknowledgeAlarmsResponse);

    //
    // Used to set a NotAcknowledgedAlarm in a monitor. 
    // For each given monitor:
    //      - if it belongs to a group of monitors, the alarm is set in it, moving the active alarm in that 
    //        same monitor, if present, to another position in the stack. This does NOT ACKNOWLEDGE the alarm.
    //      - if it doesn't belong to a group of monitor, i.e., if it's a normal monitor, the alarm is set in 
    //        it and the alarm is ACKNOWLEDGED!
    // 
    // TAO IDL:
    //          For a group monitor:
    //          - int setAlarmOnMonitor(workstationInformation_ logInfo, long alarmId, int monitorId);
    //          or if the given monitor is groupless monitor:
    //          - int ackAlarmToTarget(workstationInformation_ logInfo, long alarmId, int monitorId); - THIS ACKNOWLEDGE THE ALARM(s).
    rpc SetAlarmsOnMonitor(SetAlarmsOnMonitorRequest) returns (MultipleRequestsResponse);

    //
    // Used to reset a monitors group.
    // TAO IDL:
    //          - int resetMonitorGroup(int groupId);
    rpc ResetMonitorGroups(ListIds) returns (MultipleRequestsResponse);









    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // User alarm marking operations
    //

    //
    // Used to mark an user/manual alarm associated with the given source identification. 
    // This method return information is the marking handle which can be used to change the user marking.
    // TAO IDL:
    //          - int markUserAlarm(workstationInformation_ logInfo, int userId, int SourceId, int alarmSubtypeId, sTag, sSensorAlarmSubtypeTagId, sNotes, IntHolder alarmId);
    rpc MarkUserAlarm(MarkUserAlarmRequest) returns (NumericResponse);

    //
    // Used to edit user/manual alarm markings data. 
    // TAO IDL:
    //          - int changeUserMarkAlarm(workstationInformation_ logInfo, int alarmId, int userId, String sTag, String sSensorAlarmSubtypeTagId, String notes, boolean isMarkingEnd);
    rpc EditUserMarkAlarm(MarkUserAlarmEditRequest) returns (Response);

    //
    // Returns sensor alarm types. Normally used in the user alarms marking operations.
    // TAO IDL:
    //          - ???????
    // NOTE: probably we need to implement this in the CCTV module or adding a TAO API in the configuration IDL.
    //       DB access???
    rpc GetSensorAlarmTypes(WorkstationInformation) returns (ListSensorAlarmTypesResponse);

    //
    // Returns sensor alarm subtypes. Normally used in the user alarms marking operations.
    // TAO IDL:
    //          - ???????
    // NOTE: probably we need to implement this in the CCTV module or adding a TAO API in the configuration IDL.
    //       DB access???
    rpc GetSensorAlarmSubtypes(WorkstationInformation) returns (ListSensorAlarmSubtypesResponse);

    //
    // Returns sensor alarm subtype tags. Normally used in the user alarms marking operations.
    // TAO IDL:
    //          - ???????
    // NOTE: probably we need to implement this in the CCTV module or adding a TAO API in the configuration IDL.
    //       DB access???
    rpc GetSensorAlarmSubtypesTags(WorkstationInformation) returns (ListSensorAlarmSubtypesTagsResponse);









    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Equipments interfaces 
    //

    // 
    // Lock/Unlock equipments, normally cameras. The r
    // NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
    //       is OK, there's no need to use the specific lock/unlock response item.
    // 
    //  Param:
    //
    //  Returns: the return is a little bit tricky. To really check for the operation "ping" 
    //           return success this method MUST be called w/ an array of equips with ONLY ONE element.    
    //
    // TAO IDL: 
    //          - int ping(int IG, int priorityLevel, int[] lockedEquips, int IGTimeout);
    //          - int releaseEquipment(workstationInformation_ logInfo, int equipId, int IG, int priorityLevel);
    rpc LockUnlockEquipments(LockUnlockEquipsRequest) returns (MultipleRequestsResponse);

    // 
    // Get ALL locked equipments, normally cameras.
    // TAO IDL: 
    //          - int getLockedEquipments(...);
    rpc GetLockedEquipments(WorkstationInformation) returns (NumericsResponse);

    //
    // From the given list of equipments, obtain all its states.
    // TAO IDL: 
    //          - int getState(int EqId);
    rpc GetEquipmentsGenericState(ListIds) returns (EquipmentsGenericStateResponse);

    //
    // From the given list of equipments, obtain all its specific states.
    // TAO IDL: 
    //          - int getSpecificState(int EqId);
    rpc GetEquipmentsSpecificState(ListIds) returns (EquipmentsSpecificStateResponse);

    //
    // From the given list of equipments, return all its connection information, generic and specific configuration
    // TAO IDL: 
    //          - String getGenericConfiguration(int EqId);
    //          - String getSpecificConfiguration(int EqId);
    //          - String getCommunicationSettings(int EqId); 
    //
    // TODO: NEEDS IMPLEMENTATION ON THE StvSa!!!!
    //
    rpc GetEquipmentsConfiguration(ListIds) returns (EquipmentsConfigurationResponse);

    //
    // Execute all ptzf cameras presets operations: activate, add, update or delete.
    //
    // NOTE: THIS METHOD WILL CALL THE EQUIPMENT (not only the database).
    //
    // TAO IDL:
    //          - int ptzfActivatePreset(int EqId, short nPreset);
    //          - int ptzfStorePreset(workstationInformation_ logInfo, int EqId, short nPreset);
    //          and, for saving the real preset name, call the configuraion.idl API "storePreset(PresetConfigStv_)";
    //          - int ptzfDeletePreset(workstationInformation_ logInfo, int EqId, short nPreset);
    rpc CamerasPtzfPresetsOperation(CameraPtzfSavePresetsRequest) returns (CameraPtzfSavePresetsResponse);

    //
    // Execute all actuator operations: actuate or deactuate.
    // TAO IDL:
    //          - int actuate(workstationInformation_ logInfo, int EqId, int lDuration);
    //          - int deactuate(workstationInformation_ logInfo, int EqId);
    rpc ExecActuatorOperation(ActuatorOperationsRequest) returns (ActuatorOperationsResponse);

    //
    // Used to signal the CCTV service that the cameras associated with the given MobileCamHomePos 
    // were PTZFed, i.e., moved, so, CCTV service should proccess the camera PTZF accordingly, normally 
    // and if the "Return to Home Position" is enabled, reset/restart the timer to move the PTZF camera
    // to its Home position after the configured timeout.  
    // This API is also used to configure the "Go to Home Position" feature.
    // TAO IDL:
    //          - 	int ptzf(workstationInformation_ logInfo, MobileCamHomePosReturn_[]);
    rpc PtzfOperationExecuted(MobileCameraAutoHomePositionActivationsRequest) returns (MultipleRequestsResponse);

    //
    // Returns all the "Go to Home Position" mobile cameras configurations.
    // TAO IDL:
    //          - int getMobileCamerasHomePosConfig(workstationInformation_, listMobileCamHomePosReturnHolder);
    rpc GetMobileCamerasAutoHomePositionActConfig(WorkstationInformation) returns (ListMobileCameraAutoHomePositionActivationsResponse);

    // 
    // Used to delete mobile cameras "Go to Home Position" configurations.
    // TAO IDL:
    //          - int deleteMobileCamerasHomePosConfig(workstationInformation_ , MobileCamHomePosReturn_[] );
    rpc DeleteMobileCamerasAutoHomePositionAct(MobileCameraAutoHomePositionActivationsRequest) returns (MultipleRequestsResponse);







    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sequences interfaces 
    //

    // Starting sequences in the targets, normally monitors, all given in the StartSeqsInTargetsRequest message.
    // TAO IDL: 
    //          - int setSequenceinTarget(workstationInformation_ logInfo, int SeqID, int TargetID);
    rpc StartSequences(StartSequencesRequest) returns (RunningSequencesResponse);

    // For all given sequences, executes the given operation: stop, pause, restart and steps forward and backward.
    // TAO IDL:
    //          - int stopSequence(workstationInformation_ logInfo, int SeqHdl);
    //          - int startSequence(workstationInformation_ logInfo, int SeqHdl);
    //          - int pauseSequence(workstationInformation_ logInfo, int SeqHdl);
    //          - int showNextStep(int SeqHdl);
    //          - int showPreviousStep(int SeqHdl);
    //          or if we desire to stop all running sequences using the given sequence id:
    //          - int stopAllSequences(workstationInformation_ logInfo, int SeqId);
    rpc ExecSequencesOperation(SequencesOperationRequest) returns (RunningSequencesResponse);

    // Obtain all running sequences. 
    // The request can be filter by the given WorkStation, targets, sequences handles, etc, 
    // configured in the RunningSequencesRequest parameter, if any.
    // Can be used to obtain:
    //      - all running sequences, if the given parameter is unset; 
    //      - sequences states; 
    //      - which, if any, sequences are active in the given targets;
    //      - etc.
    // 
    // TAO IDL: 
    //      - void getRunningSeqs(...); (returns ALL running seqs BUT NO HANDLE)
    //      - int getSequenceInTargetData(int targetId, ...); (returns all info)
    //      - int getSequenceInTarget(int targetId); (we returns the sequence handle)
    rpc GetRunningSequences(RunningSequencesRequest) returns (RunningSequencesResponse);







    /////////////////////////////////////////////////////////////////////////////
    // Macros interfaces 
    //

    // For all given macros, executes the given operation, i.e., start or stop.
    // NOTE: if the globalResponse, present in the returned MultipleRequestsResponse, 
    //       is OK, there's no need to use the specific macro response item.
    // TAO IDL: 
    //          - int runMacro(workstationInformation_ logInfo, int macroId); (return the macro handle)
    //          - stopMacro(macroHandle)
    rpc ExecMacrosOperation(MacrosOperationRequest) returns (MacroOperationsResponse);

}
    



























































////////////////////////////////////////////////////////////////////////////////////
//
// CCTV configuration interface (TAO IDL: configuration.idl)
//
//
service Configuration {
    
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Generic interfaces
    //

    //
    // Used to obtain all the network data: agent, stations, equipment classes, equipment types and equipments.
    // If the given ListIds has no ids set, it means all configured agent information should be returned.
    //
    // NOTE: THIS IS NOT RELATED WITH THE GUI/GI STV DATABASE TABLES (T_IG_*).
    //
    // TAO IDL:
    //          - int getAgentConfigByID(int ID, AgentConfigStv_Holder, listStationsHolder, listEquipClassesHolder, listEquipTypesConfHolder, listEquipsConfHolder, lastUpdated);
    rpc GetAgentNetworkConfigById(ListIds) returns (CctvConfigResponse);






    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Equipments interfaces
    //
    
    //
    // Returns 
    // TAO IDL: 
    //          - ??????? int getAllEquipsConf(int stationId, listEquipsConfHolder lEquips); ??????
    // TODO: probably will required MORE developments in StvSa. There's no such API as "getAllEquips(..)"'
    rpc GetAllEquipments(ListIds) returns (ListEquipmentsResponse);

    //
    // Used to obtain cameras presets.
    // TAO IDL:
    //          - int getAllPresets(int cameraId, listPresetsHolder);
    rpc GetCamerasPresets(CamerasPresetsRequest) returns (CamerasPresetsResponse);

    //
    // Used to edit a cameras preset.
    //
    // NOTE: THIS METHOD WILL ONLY CHANGE THE STV DATABASE CAMERA PRESET DATA (it will not change anything in the equipment).
    //
    // TAO IDL:
    //          - int storePreset(PresetConfigStv_);
    rpc CamerasPresetsEdition(CamerasPresetsEditionRequest) returns (CamerasPresetsEditionResponse);



    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sequences interfaces 
    //
    
    //
    // Obtain ALL configured sequences in the system.
    // If the given ListIds is empty, or null, this method returns ALL sequences basic data otherwise, 
    // it filters the result by ListIds identifications which relates to sequences identifications.
    // TAO IDL: 
    //          - int getAllVidSeqs(listVidSeqsHolder);
    //          - getVidSeqByID(VidSeqID, VideoSequenceConfigStv);
    rpc GetAllSequences(ListIds) returns (ListSequencesResponse);

    //
    // Used to add, basic and full edition, delete sequences and also edit and delete specific sequences operations (this last two must already exist).
    // TAO IDL:
    //          - int addNewVidSeq(workstationInformation_, VideoSequenceConfigStv_); (SequenceConfig.SEQCONF_ADD)
    //          - int saveVidSeq(workstationInformation_, VideoSequenceConfigStv_ ); (SequenceConfig.SEQCONF_EDIT_BASIC)
    //          - int saveVidSeqFull(workstationInformation_, VideoSequenceConfigStv_, VidSeqOperationConfigStv_[]); (SequenceConfig.SEQCONF_EDIT_FULL)
    //          - int deleteVidSeq(workstationInformation_ logInfo, int VidSeqID); (SequenceConfig.SEQCONF_DELETE)
    //          - int saveVidSeqOperation(VidSeqOperationConfigStv_); (SequenceConfig.SEQCONF_SAVE_OPERATION)
    //          - int deleteVidSeqOperation(int VidSeqID, int nPos); (SequenceConfig.SEQCONF_DELETE_OPERATION)
    rpc ExecSequenceConfiguration(SequenceConfigRequest) returns (SequenceConfigResponse);

    // 
    // Obtains, for the given sequences, its list of operations. 
    // TAO IDL:
    //          - int getAllVidSeqOperations(int vidSeqId, listVidSeqOpersHolder);
    rpc GetSequencesConfiguration(ListIds) returns (ListSequenceFullDataResponse);






    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Macros interfaces 
    //
    
    //
    // Obtain ALL configured macros in the system. 
    // Returns macros basic data (not its actions and parameters); for this, use the GetMacrosConfiguration(..) API.
    // If the given ListIds is empty, or null, this method returns ALL macros otherwise, it filters 
    // the results using ListIds configured identifications which relates to the macro owner identification.
    // TAO IDL:
    //          - int getAllMacros(listMacrosHolder);
    //          - int getAllMacrosFromUser(int userId, listMacrosHolder);
    rpc GetAllMacros(ListIds) returns (ListMacrosResponse);

    //
    // Obtains macros configurations: macros, its actions and its actions parameters. 
    // It can be filtered by setting the request macro or owner id. If not set, or invalid, all macros are returned.
    // TAO IDL:
    //          - int getMacroByID(int MacroID, MacroConfigStv_Holder);
    //          - int getAllMacros(listMacrosHolder);
    //          - int getAllMacrosFromUser(int userId, listMacrosHolder);
    rpc GetMacrosConfiguration(MacrosRequest) returns (ListMacrosFullDataResponse);

    //
    // From the given MacroActionParametersRequest, we can filter the returning data according to the given macro action parameter index. 
    // If no parameter index is given, all the macro action parameters are returned, otherwise, only the desired parameter, if exists, is returned.
    // TAOL IDL:
    //          - int getAllActionParameters(int macroId, int actionNr, listActionParametersHolder );
    rpc GetMacroActionParameters(MacroActionParametersRequest) returns (ListMacroActionParameterResponse);

    //
    // Used to obtain macros actions.
    // TAO IDL:
    //          - int getAllActions(int MacroId, listActionsHolder lActions);
    rpc GetMacroActions(MacroActionsRequest) returns (ListMacroActionsResponse);

    //
    // Used to configure macro actions.
    // If the configuration operation is a save and the MacroActionConfigurationRequest.MacroActionFullData has the 
    // macroActionParameters list set, then the save is considered a FULL macro action save.
    // For a deletion only the macro identification and its action index are required.
    // TAO IDL:
    //          - int saveAction(ActionConfigStv_ Action);
    //          - int deleteAction(int MacroID, int nActionNr);
    //          - int saveActionFull(ActionConfigStv_, ActionParameterConfigStv_[]);
    rpc ExecMacroActionConfiguration(MacroActionConfigurationRequest) returns (MacroActionConfigurationResponse);

    //
    // Used to configure macros.
    // If the configuration operation is a save and the MacroActionConfigurationRequest has all its data holders set, i.e.,
    // MacroFullData[.MacroActionFullData[.MacroActionParameter]], then we're dealing with a FULL macro action save.
    // For a deletion only the macro identification is required.
    // TAO IDL:
    //          - int addNewMacro(workstationInformation_, MacroConfigStv_);
    //          - int saveMacro(workstationInformation_, MacroConfigStv_ );
    //          - int saveMacroFull(workstationInformation_, MacroConfigStv_, ActionConfigStv_[], ActionParameterConfigStv_[]);
    //          - int deleteMacro(workstationInformation_, MacroID);
    rpc ExecMacroConfiguration(MacroConfigurationRequest) returns (MacroConfigurationResponse);







    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Timer scheduled, equipment and system events reaction configurations
    //

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Equipment events reaction configurations
    // TAO IDL:
    //          - int getAllEvents(listEventConfigStvHolder); // for equipments and system events
    rpc GetEquipmentEventReactions(WorkstationInformation) returns (EquipmentEventReactionsResponse);

    //
    // Configure equipment event reactions.
    // TAO IDL:
    //          - int addNewEvent(EventConfigStv_); // for equipments and system events (returns the new evt id)
    //          - int saveEvent(EventConfigStv_); // for equipments and system events
    //          - int deleteEvent(int eventId);
    rpc ExecEquipmentEventReactionsConfiguration(EquipmentEventReactionsConfigurationRequest) returns (EquipmentEventReactionsConfigurationResponse);


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // System events reaction configurations
    // TAO IDL:
    //          - int getAllEvents(listEventConfigStvHolder); // for equipments and system events
    rpc GetSystemEventReactions(WorkstationInformation) returns (SystemEventReactionsResponse);

    //
    // Configure system event reactions.
    // TAO IDL:
    //          - int addNewEvent(EventConfigStv_); // for equipments and system events (returns the new evt id)
    //          - int saveEvent(EventConfigStv_); // for equipments and system events
    //          - int deleteEvent(int eventId);
    rpc ExecSystemEventReactionsConfiguration(SystemEventReactionsConfigurationRequest) returns (SystemEventReactionsConfigurationResponse);


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Timer scheduled events reaction configurations
    // TAO IDL:
    //          - 	int getAllScheduledActions(listScheduledActionConfigStvHolder); // for timer scheduled events
    rpc GetTimerScheduledEventReactions(WorkstationInformation) returns (TimerScheduledEventReactionsResponse);

    //
    // Configure scheduled event reactions.
    // TAO IDL:
    //          - int saveScheduledAction(ScheduledActionConfigStv_); // for timer scheduled events
    //          - int deleteEvent(int eventId);
    rpc ExecTimerScheduledEventReactionsConfiguration(TimerScheduledEventReactionsConfigurationRequest) returns (TimerScheduledEventReactionsConfigurationResponse);

    

}





