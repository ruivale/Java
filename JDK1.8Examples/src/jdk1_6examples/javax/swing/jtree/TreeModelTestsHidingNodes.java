/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * TreeModelTestsHidingNodes.java
 *
 * Created on 2/Set/2009, 10:02:10
 */
package jdk1_6examples.javax.swing.jtree;

import java.awt.Color;
import java.awt.Component;
import javax.swing.JCheckBox;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellEditor;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;


/**
 *
 * @author C2334
 */
public class TreeModelTestsHidingNodes extends javax.swing.JPanel {



  /** Creates new form TreeModelTestsHidingNodes */
  public TreeModelTestsHidingNodes() {
    //initComponents();
    initComponents2();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jScrollPane1 = new javax.swing.JScrollPane();
    jTree1 = new javax.swing.JTree();
    jPanel1 = new javax.swing.JPanel();
    jButton1 = new javax.swing.JButton();

    setLayout(new java.awt.BorderLayout());

    jScrollPane1.setViewportView(jTree1);

    add(jScrollPane1, java.awt.BorderLayout.CENTER);

    jPanel1.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.RIGHT));

    jButton1.setText("jButton1");
    jPanel1.add(jButton1);

    add(jPanel1, java.awt.BorderLayout.SOUTH);
  }// </editor-fold>//GEN-END:initComponents
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton jButton1;
  private javax.swing.JPanel jPanel1;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JTree jTree1;
  // End of variables declaration//GEN-END:variables

  private void initComponents2() {
    jTree1 = new javax.swing.JTree();

    TestTreeNode t1 = new TestTreeNode(1, "root", true);
    TestTreeNode t11 = new TestTreeNode(11, "son1", true);
    TestTreeNode t111 = new TestTreeNode(111, "grandson11", true);
    TestTreeNode t112 = new TestTreeNode(112, "grandson12", false);
    TestTreeNode t12 = new TestTreeNode(12, "son2", false);
    TestTreeNode t121 = new TestTreeNode(121, "grandson21", false);


    //TestDefaultTreeModel model = new TestDefaultTreeModel(t1);
    TreeModel model = new DefaultTreeModel(t1);
    this.jTree1.setModel(model);
    
//    model.insertNodeInto(t11, t1, t1.getChildCount());
//    model.insertNodeInto(t12, t1, t1.getChildCount());
//
//    model.insertNodeInto(t111, t11, t11.getChildCount());
//    model.insertNodeInto(t112, t11, t11.getChildCount());
//    model.insertNodeInto(t121, t12, t12.getChildCount());

    t11.add(t111);
    t11.add(t112);
    t12.add(t121);

    t1.add(t11);
    t1.add(t12);

    this.jTree1.setEditable(true);
    final TestTreeRenderer testTreeRenderer = new TestTreeRenderer();
    this.jTree1.setCellEditor(new TestTreeCellEditor(jTree1, testTreeRenderer));
    this.jTree1.setCellRenderer(testTreeRenderer);

    jScrollPane1 = new javax.swing.JScrollPane();
    jPanel1 = new javax.swing.JPanel();
    jButton1 = new javax.swing.JButton();

    setLayout(new java.awt.BorderLayout());

    jScrollPane1.setViewportView(jTree1);

    add(jScrollPane1, java.awt.BorderLayout.CENTER);

    jPanel1.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.RIGHT));

    jButton1.setText("jButton1");
    jPanel1.add(jButton1);

    add(jPanel1, java.awt.BorderLayout.SOUTH);

  }

  public static void main(String[] args) {
    TreeModelTestsHidingNodes t = new TreeModelTestsHidingNodes();
    javax.swing.JFrame f = new javax.swing.JFrame();
    f.setTitle("Tree tests");
    f.getContentPane().setLayout(new java.awt.BorderLayout());
    f.getContentPane().add(t, java.awt.BorderLayout.CENTER);
    f.setBounds(100, 100, 350, 300);
    f.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);
    f.setVisible(true);


  }
}


class TestTreeNode extends DefaultMutableTreeNode {

  boolean visible = true;
  String name = null;
  int id = -1;
  
  TestTreeNode(
      int id,
      String name,
      boolean visible) {
    super(name);
    this.visible = visible;
    this.name = name;
  }

  boolean isVisible() {
    return this.visible;
  }

  public String toPrivateString() {
    return "TestTreeNode name:" + name + " vis?" + isVisible();
  }
}

class TestTreeCellEditor extends DefaultTreeCellEditor {
  JCheckBox jCheckBox = new JCheckBox();
  Component comp;
  TestTreeNode testTreeNode;

  /**
   * 
   * @param tree
   * @param renderer
   */
  public TestTreeCellEditor(
      JTree tree,
      DefaultTreeCellRenderer renderer) {
    super(tree, renderer);
  }

  /**
   * 
   * @param tree
   * @param value
   * @param isSelected
   * @param expanded
   * @param leaf
   * @param row
   * @return
   */
  public Component getTreeCellEditorComponent(
      JTree tree,
      Object value,
      boolean isSelected,
      boolean expanded,
      boolean leaf,
      int row) {


    comp = super.getTreeCellEditorComponent(tree,
                                           value,
                                           isSelected,
                                           expanded,
                                           leaf,
                                           row);

    testTreeNode = (TestTreeNode) value;

    jCheckBox.setBackground(comp.getBackground());
    jCheckBox.setText(testTreeNode.name);
    //jCheckBox.setSelected(testTreeNode.isVisible());




    //System.out.println(testTreeNode.toPrivateString() + " ROW:" + row);

    return this.jCheckBox;
  }

}

class TestTreeRenderer extends DefaultTreeCellRenderer {
  JCheckBox jCheckBox = new JCheckBox();
  Component comp;
  TestTreeNode testTreeNode;

  public Component getTreeCellRendererComponent(final JTree tree,
                                                final Object value,
                                                final boolean sel,
                                                final boolean expanded,
                                                final boolean leaf,
                                                final int row,
                                                final boolean hasFocus) {

    comp = super.getTreeCellRendererComponent(tree,
                                         value,
                                         sel,
                                         expanded,
                                         leaf,
                                         row,
                                         hasFocus);


    testTreeNode = (TestTreeNode) value;

    jCheckBox.setBackground(comp.getBackground());
    jCheckBox.setText(testTreeNode.name);

    if(sel){
      jCheckBox.setBackground(Color.CYAN);      
    }

    //System.out.println(testTreeNode.toPrivateString() + " ROW:" + row);

    return this.jCheckBox;
  }
}


class TestDefaultTreeModel extends DefaultTreeModel {

  TestDefaultTreeModel(TestTreeNode t1) {
    super(t1);

    System.out.println("TestDefaultTreeModel("+t1.name+")");
  }

  /**
   * 
   * @param newChild
   * @param parent
   * @param index
   */
  public void insertNodeInto(MutableTreeNode newChild,
                             MutableTreeNode parent,
                             int index) {
    

    if(((TestTreeNode) newChild).isVisible()){
      super.insertNodeInto(newChild, parent, index);
      System.out.println("TestDefaultTreeModel.insertNodeInto " + ((TestTreeNode) newChild).toPrivateString() );
    }

//    System.out.println("TestDefaultTreeModel.insertNodeInto " + ((TestTreeNode) newChild) + " in " +
//                       ((TestTreeNode) parent) + " @ " + index);
  }

  /**
   * Invoke this method after you've inserted some TreeNodes into
   * node.  childIndices should be the index of the new elements and
   * must be sorted in ascending order.
   */
  public void _nodesWereInserted(TreeNode node,
                                int[] childIndices) {

    if(((TestTreeNode) node).isVisible()){
      super.nodesWereInserted(node, childIndices);
      System.out.println("TestDefaultTreeModel.nodesWereInserted " + ((TestTreeNode) node).toPrivateString() + " childs? " +
                         (childIndices!=null? childIndices.length+"": "CHILD NULL"));
    }



//        if(listenerList != null && node != null && childIndices != null
//           && childIndices.length > 0) {
//            int               cCount = childIndices.length;
//            Object[]          newChildren = new Object[cCount];
//
//            for(int counter = 0; counter < cCount; counter++)
//                newChildren[counter] = node.getChildAt(childIndices[counter]);
//            fireTreeNodesInserted(this, getPathToRoot(node), childIndices,
//                                  newChildren);
//        }
    }

  /**
   * Invoke this method after you've removed some TreeNodes from
   * node.  childIndices should be the index of the removed elements and
   * must be sorted in ascending order. And removedChildren should be
   * the array of the children objects that were removed.
   */
  public void _nodesWereRemoved(TreeNode node,
                               int[] childIndices,
                               Object[] removedChildren) {

    super.nodesWereRemoved(node, childIndices, removedChildren);

    System.out.println("TestDefaultTreeModel.nodesWereRemoved " + ((TestTreeNode) node) + " childs? " +
                       (childIndices!=null? childIndices.length+"": "CHILD NULL"));



//    if (node != null && childIndices != null) {
//      fireTreeNodesRemoved(this, getPathToRoot(node), childIndices,
//                           removedChildren);
//    }
  }
}
